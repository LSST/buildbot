# -*- python -*-
# ex: set syntax=python:

from buildbot.status import html
from buildbot.status import mail
from buildbot.status.web import authz
from buildbot.status.web.auth import BasicAuth
import re
import os


#######
# Shared globals
#######

BUILDBOT_HOME = "/lsst/home/buildbot/RHEL6"
BUILDBOT_DOXYGEN = BUILDBOT_HOME+"/doxygen"
LSST_HOME="/lsst/DC3/stacks/gcc445-RH6/28nov2011"

slave_home_dir = BUILDBOT_HOME+"/buildslaves"
slave_builds_dir = BUILDBOT_HOME+"/builds"
slave_script_dir = BUILDBOT_HOME+ "/scripts"
slave_script_prefix = "time "+slave_script_dir

buildbot_master="srp@ncsa.uiuc.edu"

#
# Buildbot http server
#
BB_HTTP="lsst-build.ncsa.illinois.edu"
BB_PORT=str(8010)

BUILDLOG_DEST=BB_HTTP+":/usr/local/home/buildbot/buildmaster/public_html/buildlogs"
BUILDLOG_URL="http://"+BB_HTTP+":"+BB_PORT+"/buildlogs"
#
# buildbot slave machines.
#

BUILDBOT_SLAVE1="lsst-build1.ncsa.illinois.edu"
BUILDBOT_SLAVE2="lsst-build2.ncsa.illinois.edu"
BUILDBOT_SLAVE3="lsst-build3.ncsa.illinois.edu"
BUILDBOT_SLAVE4="lsst9.ncsa.illinois.edu"
BUILDBOT_SLAVE5="lsst-build5.ncsa.illinois.edu"

#
# buildbot slave machines aliases
#
NIGHTLY_RELEASE_SLAVE=BUILDBOT_SLAVE1

TRUNK_VS_TRUNK_SLAVE=BUILDBOT_SLAVE2
srpTRUNK_VS_TRUNK_SLAVE=BUILDBOT_SLAVE2

ON_DEMAND_TRUNK_VS_TRUNK_SLAVE=BUILDBOT_SLAVE3
DATAREL_TRUNK_VS_TRUNK_SLAVE=BUILDBOT_SLAVE3
DOXYGEN_BUILD_SLAVE=BUILDBOT_SLAVE3

WEEKLY_RUN_SLAVE=BUILDBOT_SLAVE4
TRUNK_VS_TRUNK_NO_TESTS_SLAVE=BUILDBOT_SLAVE5


DOXYGEN_BUILD_URL="http://lsst-build.ncsa.illinois.edu/doxygen"
DOXYGEN_BUILD_DEST="lsst-build.ncsa.illinois.edu:/usr/local/home/buildbot/buildmaster/public_html/doxygen"


# This is a sample buildmaster config file. It must be installed as
# 'master.cfg' in your buildmaster's base directory.

# This is the dictionary that the buildmaster pays attention to. We also use
# a shorter alias to save typing.
c = BuildmasterConfig = {}

####### BUILDSLAVES

# The 'slaves' list defines the set of recognized buildslaves. Each element is
# a BuildSlave object, specifying a unique slave name and password.  The same
# slave name and password must be configured on the slave.
from buildbot.buildslave import BuildSlave
c['slaves'] = [
#TBD:    BuildSlave(TRUNK_VS_TRUNK_NO_TESTS_SLAVE, "buildpass1", notify_on_missing=buildbot_master, missing_timeout=300, max_builds=1),
    BuildSlave(NIGHTLY_RELEASE_SLAVE, "buildpass1", notify_on_missing=buildbot_master, missing_timeout=300, max_builds=1),
    BuildSlave(TRUNK_VS_TRUNK_SLAVE, "buildpass1", notify_on_missing=buildbot_master, missing_timeout=300, max_builds=1),
    BuildSlave(ON_DEMAND_TRUNK_VS_TRUNK_SLAVE, "buildpass1", notify_on_missing=buildbot_master, missing_timeout=300, max_builds=1),
]

# 'slavePortnum' defines the TCP port to listen on for connections from slaves.
# This must match the value configured into the buildslaves (with their
# --master option)
c['slavePortnum'] = 9989

####### CHANGESOURCES

# the 'change_source' setting tells the buildmaster how it should find out
# about source code changes. 

from buildbot.changes.gitpoller import GitPoller
c['change_source'] = []
####### SCHEDULERS

# Configure the Schedulers, which decide how to react to incoming changes.  In this
# case, just kick off a 'runtests' build

from buildbot.schedulers.timed import Nightly

nightly_release = Nightly(name="Nightly distribution server install", hour=22, minute=00, builderNames=["Nightly_Release_Build"], branch='master')

c['schedulers'] = []
c['schedulers'].append(nightly_release)

####### logs
from buildbot.process import factory

from buildbot.steps.shell import ShellCommand, WithProperties

class LogFileShellCommand(ShellCommand):
    log_files = []
    log_files.append("config.log")
    log_files.append("build.log")

    def __init__(self, **kwargs):
        # And upcall to let the base class do its work
        ShellCommand.__init__(self, **kwargs)

    def createSummary(self, log):
        for line in log.getText().split("\n"):
            for log_file in self.log_files:
                # line format is "    log file build.log saved to http://dev.lsstcorp.org/...."
                if (line.startswith("log file ") and line.find(" saved to ") >= 0):
                    split = line.split(" saved to ", 1)
                    self.addURL(split[0].split("log file ")[1], split[1])

class CustomStepShellCommand(LogFileShellCommand):
    def __init__(self, **kwargs):
        # And upcall to let the base class do its work
        LogFileShellCommand.__init__(self, **kwargs)
        self.buildName = "build in progress"

    def createSummary(self, log):
        LogFileShellCommand.createSummary(self, log)
        log_text = log.getText()
        s = re.search("BUILDING_PACKAGE=(.*)", log_text)
        if s:
            self.buildName=s.group(1)

    def describe(self, done=False):
        if self.buildName:
            return [self.buildName]
        return ["???"]

####### BUILDERS

# The 'builders' list defines the Builders, which tell Buildbot how to perform a build:
# what steps, and which slaves can execute them.  Note that any particular build will
# only take place on one slave.

from buildbot.process import factory

from buildbot.steps.shell import ShellCommand, WithProperties


################
# Nightly Release
################

release_pipeline_factory = factory.BuildFactory()

#####
# Remove old working directory
#####
release_eups_userdata = slave_home_dir+"/"+NIGHTLY_RELEASE_SLAVE.split('.')[0]+"/Release/eups_userdata"

envRelease = {'LSST_HOME':LSST_HOME, 'EUPS_USERDATA':release_eups_userdata}

release_sandbox = slave_home_dir+"/"+NIGHTLY_RELEASE_SLAVE.split('.')[0]+"/Release/sandbox"

step_update_sandbox =  LogFileShellCommand(env=envRelease, name="update buildbot environment", description="update buildbot environment", command=slave_script_prefix+"/updateBuildbotEnv.sh "+release_sandbox)
release_pipeline_factory.addStep(step_update_sandbox)
release_pipeline_factory.addStep(ShellCommand(workdir="work", name="erase", description="erase old working dir", command='rm -rf *; echo "...." $? "...."'))
#####
# execute run_newinstall.sh
#####
release_pipeline_env = {'LSST_HOME': LSST_HOME, 'LSST_DEVEL': release_sandbox }
release_pipeline_factory.addStep(ShellCommand(workdir="work", name="newinstall", description="run newinstall.sh lsstactive",
    env=release_pipeline_env, timeout=3600, command=slave_script_prefix + "/run_newinstall.sh"))

build_release_pipeline = {
        'name':'Nightly_Release_Build',
        'slavename': NIGHTLY_RELEASE_SLAVE,
        'builddir' : slave_builds_dir+'/Release',
        'factory' : release_pipeline_factory
        }

# ---------------------------
# this is for on demand builds of a package vs all other trunk packages
# You MUST fill out the "branch to build" with the right package name.
# ---------------------------
on_demand_vs_trunk_sandbox = slave_home_dir+"/"+ON_DEMAND_TRUNK_VS_TRUNK_SLAVE.split('.')[0]+"/on_demand_vs_trunk/sandbox"

on_demand_vs_trunk_eups_userdata = slave_home_dir+"/"+ON_DEMAND_TRUNK_VS_TRUNK_SLAVE.split('.')[0]+"/on_demand_vs_trunk/eups_userdata"
on_demand_vs_trunk_env = {'LSST_HOME':LSST_HOME,'LSST_DEVEL': on_demand_vs_trunk_sandbox, 'EUPS_USERDATA':on_demand_vs_trunk_eups_userdata }

on_demand_vs_trunk_factory = factory.BuildFactory()

on_demand_update_sandbox =  LogFileShellCommand(env=on_demand_vs_trunk_env, name="update buildbot environment", description="update buildbot environment", command=slave_script_prefix+"/updateBuildbotEnv.sh "+on_demand_vs_trunk_sandbox)
on_demand_vs_trunk_factory.addStep(on_demand_update_sandbox)

on_demand_vs_trunk_step_update_pipe = LogFileShellCommand(workdir="work", name="update stack", description="update stack",
   env=on_demand_vs_trunk_env, timeout=12000, command=slave_script_prefix + 
       "/gitReleasePackage.sh -lsstdir "+LSST_HOME+" -no_doxygen --tag=current lsstactive")
on_demand_vs_trunk_factory.addStep(on_demand_vs_trunk_step_update_pipe)
####
od_step_create_manifest = LogFileShellCommand(workdir="work", name="get package versions", description="get package versions", env=on_demand_vs_trunk_env, timeout=12000, command=slave_script_prefix + "/bootstrap.sh")
on_demand_vs_trunk_factory.addStep(od_step_create_manifest)


od_step_prepare_packages = LogFileShellCommand(workdir="work", name="prepare packages", description="prepare packages", env=on_demand_vs_trunk_env, timeout=12000, command=["time", slave_script_dir + "/prepareManifestPackages.sh",
        "--log_dest", BUILDLOG_DEST,
        "--log_url", BUILDLOG_URL,
        "--builder_name", WithProperties("%s", "buildername"),
        "--build_number", WithProperties("%s", "buildnumber")
        ])
on_demand_vs_trunk_factory.addStep(od_step_prepare_packages)

od_step_declare_packages = LogFileShellCommand(workdir="work", name="declare packages", description="declare packages", env=on_demand_vs_trunk_env, timeout=12000, command=slave_script_prefix + "/declareAllPackages.sh")
on_demand_vs_trunk_factory.addStep(od_step_declare_packages)

od_step_extract_dependencies = LogFileShellCommand(workdir="work", name="extract dependencies", description="extract dependencies", env=on_demand_vs_trunk_env, timeout=12000, command=slave_script_prefix + "/dependencies.sh beta stable")
on_demand_vs_trunk_factory.addStep(od_step_extract_dependencies)


####
on_demand_vs_trunk_factory.addStep( LogFileShellCommand(workdir="work", 
        name="on_demand_build",
        description="on_demand_build",
        env=on_demand_vs_trunk_env, 
        timeout=3600,
        command=["time", slave_script_dir+"/gitBuild.sh",
        "--log_dest", BUILDLOG_DEST,
        "--log_url", BUILDLOG_URL,
        "--builder_name", WithProperties("%s", "buildername"),
        "--build_number", WithProperties("%s", "buildnumber") , 
        "--step_name", "on_demand_build",
        "--parallel", 2,
        "--on_demand",
       WithProperties("%s","repository"), "trunk" ]))
#      "-no_tests", WithProperties("%s","branch"), "trunk" ]))


b_on_demand_vs_trunk = {
       'name': "On_Demand_Vs_Trunk",
       'slavename': ON_DEMAND_TRUNK_VS_TRUNK_SLAVE,
       'builddir': slave_builds_dir+"/ondemand_vs_trunk",
       'factory': on_demand_vs_trunk_factory 
}


class PackageList:

    def __init__(self,**kwargs):
        ##
        # exclude these packages
        #
        
        externals = ["sconsUtils"]
        for name in os.listdir("/lsst/DC3/stacks/gcc445-RH6/28nov2011/Linux64/external"):
            externals.append(name)
        exclude_pkgs=set(externals)
        
        ##
        # current_list is the URL of manifest for the lsstactive product, which
        # includes all packages.
        #
        current_list = "http://dev.lsstcorp.org/pkgs/std/w12/manifests/lsstactive-4.7.0.0+7.manifest"
        
        ##
        # createGitURL(package) - create the Git URL for a given package
        #
        def createGitURL(package):
            return "git@git.lsstcorp.org:LSST/DMS/"+package+".git"
        
        ##
        # open a the current.list URL, and remove the first line, and any lines
        # containing "pseudo", "external", or that start with a comment character
        #
        stream = os.popen("curl -s "+current_list+"|  grep -v ^EUPS| grep -v ^# | awk '{print $1 ;}'")
        
        ##
        # read all the packages of the stream, and put them into a set, removing
        # the excluded packages.
        #
        
        pkgs = stream.read().split()
        self.pkg_list = []
        for name in pkgs:
            if (name in exclude_pkgs) == False:
                self.pkg_list.append(name)
        
        
    def getPackageList(self):
        return self.pkg_list

p = PackageList()
pkgs = p.getPackageList()

# take the list of packages, create a gitPoller for them
git_watcher_uniq = []
for name in pkgs:
    #name = pkg_ver[0]
    if name in git_watcher_uniq: #skip duplicates
        continue
    #package_branch = name.replace("_", "/")
    c['change_source'].append(GitPoller("git@git.lsstcorp.org:LSST/DMS/" + name+ ".git", workdir="gitpoller_workdir/"+name, pollinterval=300))

# -- buildbot steps to 'update stack' should only define LSST_HOME
srpTvT_eups_userdata = slave_home_dir+"/"+srpTRUNK_VS_TRUNK_SLAVE.split('.')[0]+"/srpTvT/eups_userdata"

# --  Trunk Vs Trunk:  update stack
srpTvT_sandbox = slave_home_dir+"/"+srpTRUNK_VS_TRUNK_SLAVE.split('.')[0]+"/srpTvT/sandbox"

srpEnvT = {'LSST_HOME':LSST_HOME,'LSST_DEVEL': srpTvT_sandbox, 'EUPS_USERDATA':srpTvT_eups_userdata}

f_srpTvsT = factory.BuildFactory()
step_update_sandbox =  LogFileShellCommand(env=srpEnvT, name="update buildbot environment", description="update buildbot environment", command=slave_script_prefix+"/updateBuildbotEnv.sh "+srpTvT_sandbox)
f_srpTvsT.addStep(step_update_sandbox)

step_update_pipe = LogFileShellCommand(workdir="work", name="update stack", description="update stack", env=srpEnvT, timeout=12000, command=slave_script_prefix + "/gitReleasePackage.sh -lsstdir "+LSST_HOME+"  -no_doxygen --tag=current lsstactive")
f_srpTvsT.addStep(step_update_pipe)

#step_create_manifest = LogFileShellCommand(workdir="work", name="get package versions", description="get package versions", env=srpEnvT, timeout=12000, command=slave_script_prefix + "/bootstrap.py > ./manifest.list")
step_create_manifest = LogFileShellCommand(workdir="work", name="get package versions", description="get package versions", env=srpEnvT, timeout=12000, command=slave_script_prefix + "/bootstrap.sh")
f_srpTvsT.addStep(step_create_manifest)

# TODO: All the args in the command aren't used, so get rid of the ones that
# aren't necessary.  Remember that even though a build doesn't take place in
# this step, we still require the builder_name and number for failure cases
# where were e-mail gets sent.
step_prepare_packages = LogFileShellCommand(workdir="work", name="prepare packages", description="prepare packages", env=srpEnvT, timeout=12000, command=["time", slave_script_dir + "/prepareManifestPackages.sh",
        "--log_dest", BUILDLOG_DEST,
        "--log_url", BUILDLOG_URL,
        "--builder_name", WithProperties("%s", "buildername"), 
        "--build_number", WithProperties("%s", "buildnumber")
        ])
f_srpTvsT.addStep(step_prepare_packages)

step_declare_packages = LogFileShellCommand(workdir="work", name="declare packages", description="declare packages", env=srpEnvT, timeout=12000, command=slave_script_prefix + "/declareAllPackages.sh")
f_srpTvsT.addStep(step_declare_packages)

step_extract_dependencies = LogFileShellCommand(workdir="work", name="extract dependencies", description="extract dependencies", env=srpEnvT, timeout=12000, command=slave_script_prefix + "/dependencies.sh beta stable")
f_srpTvsT.addStep(step_extract_dependencies)

# -- 
# this is from a step we used to create a master dependencies file, which
# is no longer used.
#step_master_dependencies = LogFileShellCommand(workdir="work", name="create master dependencies", description="create master dependencies", env=srpEnvT, timeout=12000, command=slave_script_prefix + "/masterdeps.py >./master.deps")
#f_srpTvsT.addStep(step_master_dependencies)

trunk_uniq = []
all_packages = ""
count = 0
for name in pkgs:
    #name = pkg_ver[0]
    if name in trunk_uniq: #skip duplicates
        continue
    trunk_uniq.append(name)
    all_packages = all_packages + " " + name

    # -- Trunk Vs Trunk: with test and per package
    f_srpTvsT.addStep( LogFileShellCommand(workdir="work", name=name, description="building "+name,
        env=srpEnvT, timeout=3600, command=["time", slave_script_dir + "/gitBuild.sh",
        "--log_dest", BUILDLOG_DEST,
        "--log_url", BUILDLOG_URL,
        "--builder_name", WithProperties("%s", "buildername"), 
        "--build_number", WithProperties("%s", "buildnumber"), 
        "--step_name", name,
        "--parallel", 2,
        name , "trunk" ]))
    count = count + 1

# -- new srp Trunk Vs Trunk (with tests)
b_srpTvsT = {
        'name': "Full_Trunk_vs_Trunk",
        'slavename': srpTRUNK_VS_TRUNK_SLAVE,
        'builddir': slave_builds_dir+"/srpTvT",
        'factory': f_srpTvsT
}
#=============================================================================
#  DOXYGEN 
#=============================================================================


# -- buildbot steps to 'update stack' should only define LSST_HOME
doxygen_eups_userdata = slave_home_dir+"/"+DOXYGEN_BUILD_SLAVE.split('.')[0]+"/doxygen_build/eups_userdata"

# --  doxyxgen sandbox
doxygen_sandbox = slave_home_dir+"/"+DOXYGEN_BUILD_SLAVE.split('.')[0]+"/doxygen_build/sandbox"

# -- doxygen Env
doxygenEnvT = {'LSST_HOME':LSST_HOME,'LSST_DEVEL': doxygen_sandbox, 'EUPS_USERDATA':doxygen_eups_userdata}

f_doxygen = factory.BuildFactory()
# -- update environment
step_update_doxygen_sandbox =  LogFileShellCommand(env=doxygenEnvT, name="update buildbot environment", description="update buildbot environment", command=slave_script_prefix+"/updateBuildbotEnv.sh "+doxygen_sandbox)
f_doxygen.addStep(step_update_doxygen_sandbox)

# -- update stack
step_update_doxygen_pipe = LogFileShellCommand(workdir="work", name="update stack", description="update stack", env=doxygenEnvT, timeout=12000, command=slave_script_prefix + "/gitReleasePackage.sh -lsstdir "+LSST_HOME+"  -no_doxygen --tag=current lsstactive")
f_doxygen.addStep(step_update_doxygen_pipe)

# -- build stable doxygen
step_build_stable_pipe = LogFileShellCommand(workdir="work", name="build stable doxygen", description="build stable doxygen", env=doxygenEnvT, timeout=12000, command=slave_script_prefix + "/create_xlinkdocs.sh stable "+DOXYGEN_BUILD_DEST+" "+DOXYGEN_BUILD_URL)
f_doxygen.addStep(step_build_stable_pipe)

step_build_beta_pipe = LogFileShellCommand(workdir="work", name="build beta doxygen", description="build beta doxygen", env=doxygenEnvT, timeout=12000, command=slave_script_prefix + "/create_xlinkdocs.sh beta "+DOXYGEN_BUILD_DEST+" "+DOXYGEN_BUILD_URL)
f_doxygen.addStep(step_build_beta_pipe)

b_doxygen = {
        'name': "doxygen build",
        'slavename': DOXYGEN_BUILD_SLAVE,
        'builddir': slave_builds_dir+"/doxygen_build",
        'factory': f_doxygen
}

#=============================================================================

#=============================================================================
#  Final Setup for Buildbot Master
#=============================================================================

####### STATUS TARGETS

# 'status' is a list of Status Targets. The results of each build will be
# pushed to these targets. buildbot/status/*.py has a variety to choose from,
# including web pages, email senders, and IRC bots.

from buildbot.status.builder import Results

def messageFormatter(mode, name, build, results, master_status):
    result = Results[results]
    text = list()
    text.append("STATUS: %s" % result.title())
    return {
        'body' : "\n".join(text),
        'type' : 'plain'
    }


c['status'] = []

# this is temporary until we can get the bot that's getting to buildbot and forcing builds stopped at the firewall
users = [('srp', 'test'), ('raa', 'test')]
def canForceBuild(username, builder_status):
         if username == 'srp':
             return True
         elif username == 'raa':
             return True
         else:
             return False
     
authz_cfg = authz.Authz(auth=BasicAuth(users), gracefulShutdown=False, forceBuild=canForceBuild, forceAllBuilds=False, pingBuilder=False, stopBuild=canForceBuild, stopAllBuilds=False, cancelPendingBuild=True)

# Put this back in once the bot is stopped.
#authz_cfg=authz.Authz(
#    # change any of these to True to enable; see the manual for more
#    # options
#    gracefulShutdown = False,
#    forceBuild = True, # use this to test your slave once it is set up
#    forceAllBuilds = True,
#    pingBuilder = False,
#    stopBuild = True,
#    stopAllBuilds = False,
#    cancelPendingBuild = True,
#)
c['status'].append(html.WebStatus(http_port=8010, authz=authz_cfg))

c['status'].append(mail.MailNotifier(fromaddr=buildbot_master,
    extraRecipients=[buildbot_master],
    mode="problem",    sendToInterestedUsers=True))

######

from buildbot.config import BuilderConfig

c['builders'] = []
c['builders'].append(build_release_pipeline)
c['builders'].append(b_doxygen)
#c['builders'].append(b_TvsT)
c['builders'].append(b_srpTvsT)
c['builders'].append(b_on_demand_vs_trunk)
#TBD:c['builders'].append(b_TvsTNT)

####### PROJECT IDENTITY

# the 'title' string will appear at the top of this buildbot
# installation's html.WebStatus home page (linked to the
# 'titleURL') and is embedded in the title of the waterfall HTML page.

c['title'] = "LSST Build"
c['titleURL'] = "http://dev.lsstcorp.org/build"

# the 'buildbotURL' string should point to the location where the buildbot's
# internal web server (usually the html.WebStatus page) is visible. This
# typically uses the port number set in the Waterfall 'status' entry, but
# with an externally-visible host name which the buildbot cannot figure out
# without some help.

c['buildbotURL'] = BUILDLOG_URL

####### DB URL

# This specifies what database buildbot uses to store change and scheduler
# state.  You can leave this at its default for all but the largest
# installations.
c['db_url'] = "sqlite:///state.sqlite"

