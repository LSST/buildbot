# -*- python -*-
# ex: set syntax=python:

from buildbot.status import html
from buildbot.status import mail
from buildbot.status.web import authz


#######
# Shared globals
#######

BUILDBOT_HOME = "/lsst/home/buildbot/RHEL6"
BUILDBOT_DOXYGEN = BUILDBOT_HOME+"/doxygen"
LSST_HOME="/lsst/DC3/stacks/gcc445-RH6/28nov2011"

slave_home_dir = BUILDBOT_HOME+"/buildslaves"
slave_builds_dir = BUILDBOT_HOME+"/builds"
slave_scripts_dir = BUILDBOT_HOME+ "/scripts"
slave_script_prefix = "time "+slave_scripts_dir

buildbot_master="srp@ncsa.uiuc.edu"

#
# Buildbot http server
#
BB_HTTP="lsst-build.ncsa.illinois.edu"
BB_PORT=str(8010)

BUILDLOG_DEST=BB_HTTP+":/usr/local/home/buildbot/buildmaster/public_html/buildlogs"
BUILDLOG_URL="http://"+BB_HTTP+":"+BB_PORT+"/buildlogs"
#
# buildbot slave machines.
#

BUILDBOT_SLAVE1="lsst-build1.ncsa.illinois.edu"

BUILDBOT_SLAVE2="lsst-build2.ncsa.illinois.edu"

BUILDBOT_SLAVE3="lsst-build3.ncsa.illinois.edu"

BUILDBOT_SLAVE4="lsst9.ncsa.illinois.edu"
BUILDBOT_SLAVE5="lsst-build5.ncsa.illinois.edu"

#
# buildbot slave machines aliases
#
NIGHTLY_RELEASE_SLAVE=BUILDBOT_SLAVE1

TRUNK_VS_TRUNK_SLAVE=BUILDBOT_SLAVE2
ON_DEMAND_TRUNK_VS_TRUNK_SLAVE=BUILDBOT_SLAVE3
TRUNK_VS_TRUNK_NO_TESTS_SLAVE=BUILDBOT_SLAVE5

DATAREL_TRUNK_VS_TRUNK_SLAVE=BUILDBOT_SLAVE3

WEEKLY_RUN_SLAVE=BUILDBOT_SLAVE4



# This is a sample buildmaster config file. It must be installed as
# 'master.cfg' in your buildmaster's base directory.

# This is the dictionary that the buildmaster pays attention to. We also use
# a shorter alias to save typing.
c = BuildmasterConfig = {}

####### BUILDSLAVES

# The 'slaves' list defines the set of recognized buildslaves. Each element is
# a BuildSlave object, specifying a unique slave name and password.  The same
# slave name and password must be configured on the slave.
from buildbot.buildslave import BuildSlave
c['slaves'] = [
#TBD:    BuildSlave(TRUNK_VS_TRUNK_NO_TESTS_SLAVE, "CHANGEME", notify_on_missing=buildbot_master, missing_timeout=300, max_builds=1),
    BuildSlave(NIGHTLY_RELEASE_SLAVE, "CHANGEME", notify_on_missing=buildbot_master, missing_timeout=300, max_builds=1),
    BuildSlave(ON_DEMAND_TRUNK_VS_TRUNK_SLAVE, "CHANGEME", notify_on_missing=buildbot_master, missing_timeout=300, max_builds=1),
    BuildSlave(TRUNK_VS_TRUNK_SLAVE, "CHANGEME", notify_on_missing=buildbot_master, missing_timeout=300, max_builds=1),
]

# 'slavePortnum' defines the TCP port to listen on for connections from slaves.
# This must match the value configured into the buildslaves (with their
# --master option)
c['slavePortnum'] = 9989

####### CHANGESOURCES

# the 'change_source' setting tells the buildmaster how it should find out
# about source code changes. 

from buildbot.changes.gitpoller import GitPoller
c['change_source'] = []
####### SCHEDULERS

# Configure the Schedulers, which decide how to react to incoming changes.  In this
# case, just kick off a 'runtests' build

from buildbot.schedulers.timed import Nightly

c['schedulers'] = []

####### logs
from buildbot.process import factory

from buildbot.steps.shell import ShellCommand, WithProperties

class LogFileShellCommand(ShellCommand):
    log_files = []
    log_files.append("config.log")
    log_files.append("build.log")

    def __init__(self, **kwargs):
        # And upcall to let the base class do its work
        ShellCommand.__init__(self, **kwargs)

    def createSummary(self, log):
        for line in log.getText().split("\n"):
            for log_file in self.log_files:
                # line format is "    log file build.log saved to http://dev.lsstcorp.org/...."
                if (line.startswith("log file ") and line.find(" saved to ") >= 0):
                    split = line.split(" saved to ", 1)
                    self.addURL(split[0].split("log file ")[1], split[1])

####### BUILDERS

# The 'builders' list defines the Builders, which tell Buildbot how to perform a build:
# what steps, and which slaves can execute them.  Note that any particular build will
# only take place on one slave.

from buildbot.process import factory

from buildbot.steps.shell import ShellCommand, WithProperties


################
# Nightly Release
################

release_pipeline_factory = factory.BuildFactory()

#####
# Remove old working directory
#####
release_eups_userdata = slave_home_dir+"/"+NIGHTLY_RELEASE_SLAVE.split('.')[0]+"/Release/eups_userdata"

envRelease = {'LSST_HOME':LSST_HOME, 'EUPS_USERDATA':release_eups_userdata}

release_sandbox = slave_home_dir+"/"+NIGHTLY_RELEASE_SLAVE.split('.')[0]+"/Release/sandbox"

step_update_sandbox =  LogFileShellCommand(env=envRelease, name="update buildbot environment", description="update buildbot environment", command=slave_script_prefix+"/updateBuildbotEnv.sh "+release_sandbox)
release_pipeline_factory.addStep(step_update_sandbox)
release_pipeline_factory.addStep(ShellCommand(workdir="work", name="erase", description="erase old working dir", command='rm -rf *; echo "...." $? "...."'))
#####
# execute run_newinstall.sh
#####
release_pipeline_env = {'LSST_HOME': LSST_HOME, 'LSST_DEVEL': release_sandbox }
release_pipeline_factory.addStep(ShellCommand(workdir="work", name="newinstall", description="run newinstall.sh lsstactive",
    env=release_pipeline_env, timeout=3600, command=slave_script_prefix + "/run_newinstall.sh"))

build_release_pipeline = {
        'name':'Nightly_Release_Build',
        'slavename': NIGHTLY_RELEASE_SLAVE,
        'builddir' : slave_builds_dir+'/Release',
        'factory' : release_pipeline_factory
        }

# ---------------------------
# this is for on demand builds of a package vs all other trunk packages
# You MUST fill out the "branch to build" with the right package name.
# ---------------------------
on_demand_vs_trunk_sandbox = slave_home_dir+"/"+ON_DEMAND_TRUNK_VS_TRUNK_SLAVE.split('.')[0]+"/on_demand_vs_trunk/sandbox"

on_demand_vs_trunk_eups_userdata = slave_home_dir+"/"+ON_DEMAND_TRUNK_VS_TRUNK_SLAVE.split('.')[0]+"/on_demand_vs_trunk/eups_userdata"
on_demand_vs_trunk_env = {'LSST_HOME':LSST_HOME,'LSST_DEVEL': on_demand_vs_trunk_sandbox, 'EUPS_USERDATA':on_demand_vs_trunk_eups_userdata }

on_demand_vs_trunk_factory = factory.BuildFactory()

on_demand_update_sandbox =  LogFileShellCommand(env=on_demand_vs_trunk_env, name="update buildbot environment", description="update buildbot environment", command=slave_script_prefix+"/updateBuildbotEnv.sh "+on_demand_vs_trunk_sandbox)
on_demand_vs_trunk_factory.addStep(on_demand_update_sandbox)

on_demand_vs_trunk_step_update_pipe = LogFileShellCommand(workdir="work", name="update stack", description="update stack",
   env=on_demand_vs_trunk_env, timeout=12000, command=slave_script_prefix + 
       "/gitReleasePackage.sh -lsstdir "+LSST_HOME+" -no_doxygen --tag=current lsstactive")

on_demand_vs_trunk_factory.addStep(on_demand_vs_trunk_step_update_pipe)
on_demand_vs_trunk_factory.addStep( LogFileShellCommand(workdir="work", name="on demand trunkVtrunk",
        env=on_demand_vs_trunk_env, timeout=3600, command=["time", slave_scripts_dir+"/gitTvT2.sh",
        "--log_dest", BUILDLOG_DEST,
        "--log_url", BUILDLOG_URL,
        "--builder_name", WithProperties("%s", "buildername"),
        "--build_number", WithProperties("%s", "buildnumber") , 
        "--slave_devel", on_demand_vs_trunk_sandbox,
       "--parallel", 2,
       WithProperties("%s","repository"), "trunk" ]))
#      "-no_tests", WithProperties("%s","branch"), "trunk" ]))


b_on_demand_vs_trunk = {
       'name': "On_Demand_Vs_Trunk",
       'slavename': ON_DEMAND_TRUNK_VS_TRUNK_SLAVE,
       'builddir': slave_builds_dir+"/ondemand_vs_trunk",
       'factory': on_demand_vs_trunk_factory 
}


# -- Collect module names for all DM modules
import urllib2
f = urllib2.urlopen("http://dev.lsstcorp.org/pkgs/std/w12/current.list")
manifest_lines = f.readlines()
pkgs = []
try:
    for line in manifest_lines:
        line = line.strip()
        if line.startswith('EUPS') or line.startswith('#') or line.find("external") >= 0 or  line.find("pseudo") >= 0 or line.find("LSSTPipe") >= 0:
            continue
        try:
            # name, flavor, version, tablefile, installDir, install id
            parts = line.split()
            if parts[0] == "scons":
                continue
            pkgs.append([parts[0]])
        except IndexError:
            pass
finally:
    f.close()

# take the list of packages, create a gitPoller for them
git_watcher_uniq = []
for pkg_ver in pkgs:
    name = pkg_ver[0]
    if name in git_watcher_uniq: #skip duplicates
        continue
    package_branch = name.replace("_", "/")
    c['change_source'].append(GitPoller("git@git.lsstcorp.org:LSST/DMS/" + package_branch + ".git", workdir="gitpoller_workdir/"+package_branch, pollinterval=300))

# -- buildbot steps to 'update stack' should only define LSST_HOME
TvT_eups_userdata = slave_home_dir+"/"+TRUNK_VS_TRUNK_SLAVE.split('.')[0]+"/TVT/eups_userdata"
envH = {'LSST_HOME':LSST_HOME, 'EUPS_USERDATA':TvT_eups_userdata}

# -------------------------------------------------------------------------
#    full trunk builds - either triggered or scheduled 
#    "Full Trunk vs Current"  "Full Trunk vs Minimal"  "Full Trunk vs Trunk" "Datarel Trunk vs Trunk"
# -------------------------------------------------------------------------
# -- all Trunk builds need both LSST_HOME and LSST_DEVEL defined in path.
#TBD:TvsTNT_sandbox = slave_home_dir+"/"+TRUNK_VS_TRUNK_NO_TESTS_SLAVE.split('.')[0]+"/sandbox"
#TBD:envTNT = {'LSST_HOME':LSST_HOME,'LSST_DEVEL': TvsTNT_sandbox}

# -- shared steps among builds: "Full Trunk vs Current"  "Full Trunk vs Minimal"
# --                         : "Full Trunk vs Trunk" "Full Trunk vs Trunk NoTest"
# --                         : "Datarel Trunk vs Trunk"
# -- Trunk Vs Trunk NoTest: update stack
#TBD:f_TvsTNT = factory.BuildFactory()
#TBD:step_update_pipe = LogFileShellCommand(workdir="work", name="update stack", description="update stack", env=envH, timeout=12000, command=slave_script_prefix + "/gitReleasePackage.sh -lsstdir "+LSST_HOME+" -no_doxygen --tag=current lsstactive")
#TBD:f_TvsTNT.addStep(step_update_pipe)
# -- Trunk Vs Trunk NoTest: create local package manifest


# --  Trunk Vs Trunk:  update stack
TvsT_sandbox = slave_home_dir+"/"+TRUNK_VS_TRUNK_SLAVE.split('.')[0]+"/TVT/sandbox"

envT = {'LSST_HOME':LSST_HOME,'LSST_DEVEL': TvsT_sandbox, 'EUPS_USERDATA':TvT_eups_userdata}

f_TvsT = factory.BuildFactory()
step_update_sandbox =  LogFileShellCommand(env=envH, name="update buildbot environment", description="update buildbot environment", command=slave_script_prefix+"/updateBuildbotEnv.sh "+TvsT_sandbox)
f_TvsT.addStep(step_update_sandbox)
step_update_pipe = LogFileShellCommand(workdir="work", name="update stack", description="update stack", env=envT, timeout=12000, command=slave_script_prefix + "/gitReleasePackage.sh -lsstdir "+LSST_HOME+"  -no_doxygen --tag=current lsstactive")
f_TvsT.addStep(step_update_pipe)
step_create_manifest = LogFileShellCommand(workdir="work", name="create manifest", description="create manifest", env=envT, timeout=12000, command=slave_script_prefix + "/bootstrap.py > ./manifest.list")
f_TvsT.addStep(step_create_manifest)

# -- 


trunk_uniq = []
all_packages = ""
for pkg_ver in pkgs:
    name = pkg_ver[0]
    if name in trunk_uniq: #skip duplicates
        continue
    trunk_uniq.append(name)
    all_packages = all_packages + " " + name

    #--------------------------------------------------------------------
    # build trunk package against trunk -- add step per package
    #--------------------------------------------------------------------
    # Trunk Vs Trunk NoTest:  per package
#TBD:    f_TvsTNT.addStep( LogFileShellCommand(workdir="work", name=name, description=name + " trunkVtrunk",
#TBD:        env=envTNT, timeout=3600, command=["time", slave_scripts_dir + "/gitTrunkVsTrunk.sh",
#TBD:        "-log_dest", "lsst-build:/usr/local/home/buildbot/buildmaster/public_html/buildlogs", 
#TBD:        "-log_url", "http://lsst-build:8010/buildlogs",
#TBD:        "-builder_name", WithProperties("%s", "buildername"), 
#TBD:        "-build_number", WithProperties("%s", "buildnumber"), 
#TBD:        "-slave_devel", TvsTNT_sandbox, 
#TBD:        "-no_tests", 
#TBD:        "-parallel", 2,
#TBD:        name , "trunk" ]))

    # -- Trunk Vs Trunk: with test and per package
    f_TvsT.addStep( LogFileShellCommand(workdir="work", name=name, description=name + " trunkVtrunk",
#        env=envT, timeout=3600, command=["time", slave_scripts_dir + "/gitTrunkVsTrunk.sh",
        env=envT, timeout=3600, command=["time", slave_scripts_dir + "/gitTvT2.sh",
        "--log_dest", BUILDLOG_DEST,
        "--log_url", BUILDLOG_URL,
        "--builder_name", WithProperties("%s", "buildername"), 
        "--build_number", WithProperties("%s", "buildnumber"), 
        "--slave_devel", TvsT_sandbox, 
        "--parallel", 2,
        name , "trunk" ]))
    #--------------------------------------------------------------------
    # monitor each package for trunk source change trigger  
    # --  ?Is this superfluous since the original change_source watches the ENTIRE DMS tree (all branches)?
    #--------------------------------------------------------------------
    package_branch = name.replace("_", "/")


# -- build trunk package against trunk dependencies
# -- Trunk Vs Trunk NoTest
#TBD:b_TvsTNT = {
#TBD:        'name': "Full_Trunk_vs_Trunk_NO_TESTS",
#TBD:        'slavename': TRUNK_VS_TRUNK_NO_TESTS_SLAVE,
#TBD:        'builddir': slave_builds_dir+"/TvTNT",
#TBD:        'factory': f_TvsTNT
#TBD:}
# -- Trunk Vs Trunk (with tests)
b_TvsT = {
        'name': "Full_Trunk_vs_Trunk",
        'slavename': TRUNK_VS_TRUNK_SLAVE,
        'builddir': slave_builds_dir+"/TvT",
        'factory': f_TvsT
}
#=============================================================================
#  Final Setup for Buildbot Master
#=============================================================================

####### STATUS TARGETS

# 'status' is a list of Status Targets. The results of each build will be
# pushed to these targets. buildbot/status/*.py has a variety to choose from,
# including web pages, email senders, and IRC bots.

from buildbot.status.builder import Results

def messageFormatter(mode, name, build, results, master_status):
    result = Results[results]
    text = list()
    text.append("STATUS: %s" % result.title())
    return {
        'body' : "\n".join(text),
        'type' : 'plain'
    }


c['status'] = []

authz_cfg=authz.Authz(
    # change any of these to True to enable; see the manual for more
    # options
    gracefulShutdown = False,
    forceBuild = True, # use this to test your slave once it is set up
    forceAllBuilds = True,
    pingBuilder = False,
    stopBuild = True,
    stopAllBuilds = False,
    cancelPendingBuild = True,
)
c['status'].append(html.WebStatus(http_port=8010, authz=authz_cfg))

c['status'].append(mail.MailNotifier(fromaddr=buildbot_master,
    extraRecipients=[buildbot_master],
    mode="problem",    sendToInterestedUsers=True))

######

from buildbot.config import BuilderConfig

c['builders'] = []
c['builders'].append(build_release_pipeline)
c['builders'].append(b_TvsT)
c['builders'].append(b_on_demand_vs_trunk)
#TBD:c['builders'].append(b_TvsTNT)

####### PROJECT IDENTITY

# the 'title' string will appear at the top of this buildbot
# installation's html.WebStatus home page (linked to the
# 'titleURL') and is embedded in the title of the waterfall HTML page.

c['title'] = "LSST Build"
c['titleURL'] = "http://dev.lsstcorp.org/build"

# the 'buildbotURL' string should point to the location where the buildbot's
# internal web server (usually the html.WebStatus page) is visible. This
# typically uses the port number set in the Waterfall 'status' entry, but
# with an externally-visible host name which the buildbot cannot figure out
# without some help.

c['buildbotURL'] = BUILDLOG_URL

####### DB URL

# This specifies what database buildbot uses to store change and scheduler
# state.  You can leave this at its default for all but the largest
# installations.
c['db_url'] = "sqlite:///state.sqlite"

