# -*- python -*-
# ex: set syntax=python:

#
# Buildmaster config file. Nust be installed as 'master.cfg' in 
# buildmaster's base directory.
#
# Configuration dictionary buildmaster uses. Use short alias to save typing.
c = BuildmasterConfig = {}


from buildbot.status import html
from buildbot.status import mail
from buildbot.status.web import authz
from buildbot.status.web.auth import HTPasswdAuth
import re
import os
import subprocess

from string import maketrans


#==========================================================================
#      Legend:   Builder internal name vs Builder characteristics
#==========================================================================
# SMBRG      - Scheduled Master     Build   Rhel6 Gcc
# SMRRG      - Scheduled Master     Run     Rhel6 Gcc   (must be on Cluster)
# SMBRC      - Scheduled Master     Build   Rhel6 Clang
# SMRRC      - Scheduled Master     Run     Rhel6 Clang (must be on Cluster)
# SBBRG      - Scheduled Branch     Build   Rhel6 Gcc
# SBRRG      - Scheduled Branch     Run     Rhel6 Gcc   (must be on Cluster)

# GMBRG      - Gitchange Master     Build   Rhel6 Gcc
# GMRRG      - Gitchange Master     Run     Rhel6 Gcc   (must be on Cluster)
# GBBRG      - Gitchange Branch     Build   Rhel6 Gcc
# GBRRG      - Gitchange Branch     Run     Rhel6 Gcc   (must be on Cluster)
#
# FBBRG      - Form      UserBranch Build   Rhel6 Gcc   
# FBBRC      - Form      UserBranch Build   Rhel6 Clang 
#
# SStableBRG - Scheduled Stable     Build   Rhel6 Gcc
# SStableRRG - Scheduled Stable     Run     Rhel6 Gcc
# SBetaBRG   - Scheduled Beta       Build   Rhel6 Gcc
# SBetaRRG   - Scheduled Beta       Run     Rhel6 Gcc   (must be on Cluster)
# STagBRG    - Scheduled AltTag     Build   Rhel6 Gcc
# STagRRG    - Scheduled AltTag     Run     Rhel6 Gcc   (must be on Cluster)
# FTagBRG    - Form      UserTag    Bld&Run Rhel6 Gcc   (must be on Cluster)
#
# SDoxyBRG   - Scheduled Doxygen    Build   Rhel6 Gcc
# SCheck     - Scheduled Check


#=========================================================================
#  Globals unique to production or development environment
#     Similar conditionals also sprinkled through rest of file
#=========================================================================
BB_DEVEL = False

#              B U I L D   C O N D I T I O N A L   B L O C K
if BB_DEVEL:
    GITWORK = "gitwork"
    # Buildbot http server
    BB_HTTP="lsst-build4.ncsa.illinois.edu"
    BB_PORT=str(8020)
    BUILDLOG_DEST=BB_HTTP+":/lsst/home/buildbot/RHEL6/"+GITWORK+\
    "/buildmaster/public_html/buildlogs/"
    # 'slavePortnum' defines TCP port to listen on for connections from slaves.
    # This must match value configured into buildslaves (with --master option)
    c['slavePortnum'] = 61853
    HTPASSWD='/nfs/lsst/home/buildbot/RHEL6/'+GITWORK+'/buildmaster/.htpasswd'
else:
    GITWORK = ""
    # Buildbot http server
    BB_HTTP="lsst-build.ncsa.illinois.edu"
    BB_PORT=str(8010)
    BUILDLOG_DEST=BB_HTTP+":/usr/local/home/buildbot/buildmaster/public_html/buildlogs"
    # 'slavePortnum' defines TCP port to listen on for connections from slaves.
    # This must match value configured into buildslaves (with --master option)
    c['slavePortnum'] = 9989
    HTPASSWD='/usr/local/home/buildbot/buildmaster/.htpasswd'


def normalize(name):
    normalized = name.translate(maketrans("/","_"))
    return normalized

#=========================================================================
#  Shared Globals 
#=========================================================================
# Display diagnostics - outputs during 'buildbot checkconfig' also
PRINT_TABLE = False

# Web access to DM git repositories
LSST_DMS="git@git.lsstcorp.org:LSST/DMS/"

# Disk locations and web access points for web accessible info
DOXY_URL="http://lsst-web.ncsa.illinois.edu/~buildbot/doxygen"
DOXY_DEST="lsst-build3.ncsa.illinois.edu:/lsst/home/buildbot/public_html/doxygen"
BUILDLOG_URL="http://"+BB_HTTP+":"+BB_PORT+"/buildlogs/"
STDIO_BUILDLOG_URL="http://"+BB_HTTP+":"+BB_PORT+"/"

# Location of Compilers for GCC and CLANG
LSST_HOME_GCC = "/lsst/DC3/stacks/gcc445-RH6/28nov2011"
LSST_HOME_CLG = "/lsst/home/buildbot/CLANGSTACK"

# Tree structure of Buildbot primary directories
BUILDBOT_HOME = "/lsst/home/buildbot/RHEL6/"+GITWORK
SLAVE_HOME_DIR = BUILDBOT_HOME+"/buildslaves"
SLAVE_BUILDS_DIR = BUILDBOT_HOME+"/builds"
SLAVE_SCRIPTS_DIR = BUILDBOT_HOME+ "/scripts"

# Make sure whatever email provided below is listserv-allowed.
BUILDBOT_EMAIL="robyn@LSST.org"

# System Architect selected git-branches & eups-tags (need normalized versions)
NAMED_GIT_BRANCH = "releases/Summer2012"
NORMALIZED_NAMED_GIT_BRANCH = normalize("releases/Summer2012")
NAMED_EUPS_TAG = "v5_2"
NORMALIZED_NAMED_EUPS_TAG = normalize("v5_2")

# Globals for Validation Builds
GCCSTACK_EXTERNALS="/lsst/DC3/stacks/default/Linux64/external"
BUILD_ORDER_MANIFEST = "/nfs/lsst/home/buildbot/RHEL6/"+GITWORK+\
    "/etc/LsstStackManifest.txt"
NIGHTLY_BUILD_ORDER_MANIFEST = "/nfs/lsst/home/buildbot/RHEL6/"+GITWORK+\
    "/builds/SMBRG/work/AllPkgBuildOrderManifest"
EXCLUDED_GIT_REPOSTIORIES = "/lsst/home/buildbot/RHEL6/"+GITWORK+\
    "/etc/excluded.txt"
SUCCESSFUL_BUILD_MANIFEST = "work/lastSuccessfulBuildManifest.list"

# Globals for Validation Production Runs
PRODUCTION_PACKAGE_ROOTS = ["testing_endtoend", "datarel", "testing_pipeQA"]
DRP_CCD_COUNT_MED = "6"
DRP_CCD_COUNT_SMALL = "2"
DRP_INPUT_DATA = "obs_imSim-2012-03-15"
DRP_ASTRO_NET_DATA = "imsim-2011-08-01-0"

# Globals for Dataset Currency Check
DATASET_ROOT = "/lsst/DC3/data"
DATASETS = {'afwdata':[LSST_DMS+'testdata/afwdata.git', 
                       DATASET_ROOT+'/afwdata/master'],
            'test_subaru':[LSST_DMS+'testdata/subaru.git', 
                       DATASET_ROOT+'/testdata_subaru/master'], } 


#              B U I L D   C O N D I T I O N A L   B L O C K
if BB_DEVEL:
    #
    # buildbot slave machines.
    #
    BUILDBOT_SLAVE5="lsst-build5.ncsa.illinois.edu"
    #
    # buildbot slave machines aliases
    #
    DOXY_SLAVE                         = BUILDBOT_SLAVE5
    CHECK_SLAVE                        = BUILDBOT_SLAVE5
    STABLE_BUILD_RH6_GCC_SLAVE         = BUILDBOT_SLAVE5
    STABLE_RUN_RH6_GCC_SLAVE           = BUILDBOT_SLAVE5
    BETA_BUILD_RH6_GCC_SLAVE           = BUILDBOT_SLAVE5
    BETA_RUN_RH6_GCC_SLAVE             = BUILDBOT_SLAVE5
    NAMED_TAG_BUILD_RH6_GCC_SLAVE      = BUILDBOT_SLAVE5
    NAMED_TAG_RUN_RH6_GCC_SLAVE        = BUILDBOT_SLAVE5
    SCHED_MASTER_BUILD_RH6_GCC_SLAVE   = BUILDBOT_SLAVE5
    SCHED_MASTER_RUN_RH6_GCC_SLAVE     = BUILDBOT_SLAVE5
    SCHED_MASTER_BUILD_RH6_CLG_SLAVE   = BUILDBOT_SLAVE5
    SCHED_MASTER_RUN_RH6_CLG_SLAVE     = BUILDBOT_SLAVE5
    SCHED_BRANCH_BUILD_RH6_GCC_SLAVE   = BUILDBOT_SLAVE5
    SCHED_BRANCH_RUN_RH6_GCC_SLAVE     = BUILDBOT_SLAVE5
    GIT_MASTER_BUILD_RH6_GCC_SLAVE     = BUILDBOT_SLAVE5
    GIT_MASTER_RUN_RH6_GCC_SLAVE       = BUILDBOT_SLAVE5
    GIT_BRANCH_BUILD_RH6_GCC_SLAVE     = BUILDBOT_SLAVE5
    GIT_BRANCH_RUN_RH6_GCC_SLAVE       = BUILDBOT_SLAVE5
    USER_BRANCH_BUILD_RH6_GCC_SLAVE    = BUILDBOT_SLAVE5
    USER_BRANCH_BUILD_RH6_CLG_SLAVE    = BUILDBOT_SLAVE5
    USER_TAG_BUILD_RH6_GCC_SLAVE       = BUILDBOT_SLAVE5
else:
    #
    # buildbot slave machines.
    #
    BUILDBOT_SLAVE1="lsst-build1.ncsa.illinois.edu"
    BUILDBOT_SLAVE2="lsst-build2.ncsa.illinois.edu"
    BUILDBOT_SLAVE3="lsst-build3.ncsa.illinois.edu"
    BUILDBOT_SLAVE4="lsst9.ncsa.illinois.edu"
    BUILDBOT_SLAVE7="lsst-build7.ncsa.illinois.edu"
    BUILDBOT_SLAVE8="lsst-build8.ncsa.illinois.edu"
    #
    # buildbot slave machines aliases
    #
    DOXY_SLAVE                         = BUILDBOT_SLAVE1
    CHECK_SLAVE                        = BUILDBOT_SLAVE1
    STABLE_BUILD_RH6_GCC_SLAVE         = BUILDBOT_SLAVE8
    STABLE_RUN_RH6_GCC_SLAVE           = BUILDBOT_SLAVE4
    BETA_BUILD_RH6_GCC_SLAVE           = BUILDBOT_SLAVE8
    BETA_RUN_RH6_GCC_SLAVE             = BUILDBOT_SLAVE4
    NAMED_TAG_BUILD_RH6_GCC_SLAVE      = BUILDBOT_SLAVE8
    NAMED_TAG_RUN_RH6_GCC_SLAVE        = BUILDBOT_SLAVE4
    SCHED_MASTER_BUILD_RH6_GCC_SLAVE   = BUILDBOT_SLAVE1
    SCHED_MASTER_RUN_RH6_GCC_SLAVE     = BUILDBOT_SLAVE4
    SCHED_MASTER_BUILD_RH6_CLG_SLAVE   = BUILDBOT_SLAVE2
    SCHED_MASTER_RUN_RH6_CLG_SLAVE     = BUILDBOT_SLAVE4
    SCHED_BRANCH_BUILD_RH6_GCC_SLAVE   = BUILDBOT_SLAVE2
    SCHED_BRANCH_RUN_RH6_GCC_SLAVE     = BUILDBOT_SLAVE4
    GIT_MASTER_BUILD_RH6_GCC_SLAVE     = BUILDBOT_SLAVE3
    GIT_MASTER_RUN_RH6_GCC_SLAVE       = BUILDBOT_SLAVE4
    GIT_BRANCH_BUILD_RH6_GCC_SLAVE     = BUILDBOT_SLAVE7
    GIT_BRANCH_RUN_RH6_GCC_SLAVE       = BUILDBOT_SLAVE4
    USER_BRANCH_BUILD_RH6_GCC_SLAVE    = BUILDBOT_SLAVE7
    USER_BRANCH_BUILD_RH6_CLG_SLAVE    = BUILDBOT_SLAVE3
    USER_TAG_BUILD_RH6_GCC_SLAVE       = BUILDBOT_SLAVE4

####### BUILDSLAVES

# The 'slaves' list defines the set of recognized buildslaves. Each element is
# a BuildSlave object, specifying a unique slave name and password.  The same
# slave name and password must be configured on the slave.
from buildbot.buildslave import BuildSlave

#              B U I L D   C O N D I T I O N A L   B L O C K
if BB_DEVEL:
    c['slaves'] = [
        BuildSlave(BUILDBOT_SLAVE5, "CHANGE_TO_THE_PRODUCTION_PASS", notify_on_missing=BUILDBOT_EMAIL, missing_timeout=300, max_builds=1),
    ]
else:
    c['slaves'] = [
        BuildSlave(BUILDBOT_SLAVE1, "CHANGE_TO_THE_PRODUCTION_PASS", notify_on_missing=BUILDBOT_EMAIL, missing_timeout=300, max_builds=1),
        BuildSlave(BUILDBOT_SLAVE2, "CHANGE_TO_THE_PRODUCTION_PASS", notify_on_missing=BUILDBOT_EMAIL, missing_timeout=300, max_builds=1),
        BuildSlave(BUILDBOT_SLAVE3, "CHANGE_TO_THE_PRODUCTION_PASS", notify_on_missing=BUILDBOT_EMAIL, missing_timeout=300, max_builds=1),
        BuildSlave(BUILDBOT_SLAVE4, "CHANGE_TO_THE_PRODUCTION_PASS", notify_on_missing=BUILDBOT_EMAIL, missing_timeout=300, max_builds=1),
        BuildSlave(BUILDBOT_SLAVE7, "CHANGE_TO_THE_PRODUCTION_PASS", notify_on_missing=BUILDBOT_EMAIL, missing_timeout=300, max_builds=1),
        BuildSlave(BUILDBOT_SLAVE8, "CHANGE_TO_THE_PRODUCTION_PASS", notify_on_missing=BUILDBOT_EMAIL, missing_timeout=300, max_builds=1),
    ]


####### SCHEDULERS

# Configure the Schedulers, which decide how to react to incoming changes.  

from buildbot.schedulers.timed import Nightly
from buildbot.schedulers.basic import SingleBranchScheduler
from buildbot.schedulers.triggerable import Triggerable
from buildbot.changes import filter

# Tag Schedulers
SStableBRG = Nightly(name="Stable_Build_Rh6_Gcc", hour=7,
    minute=00, builderNames=["Stable_Build_Rh6_Gcc"], branch='master')
SStableRRG = Triggerable(name="Stable_Run_Rh6_Gcc", builderNames=["Stable_Run_Rh6_Gcc"])
SBetaBRG = Nightly(name="Beta_Build_Rh6_Gcc", hour=11,
    minute=00, builderNames=["Beta_Build_Rh6_Gcc"], branch='master')
SBetaRRG = Triggerable(name="Beta_Run_Rh6_Gcc", builderNames=["Beta_Run_Rh6_Gcc"])
STagBRG = Nightly(name=NAMED_EUPS_TAG+"_Build_Rh6_Gcc", hour=3,
    minute=00, builderNames=[NAMED_EUPS_TAG+"_Build_Rh6_Gcc"], branch='master')
STagRRG = Triggerable(name=NAMED_EUPS_TAG+"_Run_Rh6_Gcc",
    builderNames=[NAMED_EUPS_TAG+"_Run_Rh6_Gcc"])

# Master Branch Schedulers
SMBRG = Nightly(name="Master_Build_Rh6_Gcc", hour=22, 
    minute=20, builderNames=["Master_Build_Rh6_Gcc"], branch='master')
SMRRG = Triggerable(name="Master_Run_Rh6_Gcc", builderNames=["Master_Run_Rh6_Gcc"])
SMBRC = Nightly(name="Master_Build_Rh6_Clg", hour=6, 
    minute=20, builderNames=["Master_Build_Rh6_Clg"], branch='master')
SMRRC = Triggerable(name="Master_Run_Rh6_Clg", builderNames=["Master_Run_Rh6_Clg"])

GMBRG = SingleBranchScheduler(name="Git_Master_Build_Rh6_Gcc",
    change_filter = filter.ChangeFilter(branch="master"),
    treeStableTimer=300, builderNames=["Git_Master_Build_Rh6_Gcc"])
GMRRG = Triggerable(name="Git_Master_Run_Rh6_Gcc",
    builderNames=["Git_Master_Run_Rh6_Gcc"])

# Named Branch Schedulers
SBBRG = Nightly(name=normalize(NAMED_GIT_BRANCH)+"_Build_Rh6_Gcc", hour=2,
    minute=20, builderNames=[normalize(NAMED_GIT_BRANCH)+"_Build_Rh6_Gcc"], branch=NAMED_GIT_BRANCH)
SBRRG = Triggerable(name=normalize(NAMED_GIT_BRANCH)+"_Run_Rh6_Gcc", 
    builderNames=[normalize(NAMED_GIT_BRANCH)+"_Run_Rh6_Gcc"])
GBBRG = SingleBranchScheduler(name="Git_"+normalize(NAMED_GIT_BRANCH)+"_Build_Rh6_Gcc",
    change_filter = filter.ChangeFilter(branch=NAMED_GIT_BRANCH),
    treeStableTimer=300, builderNames=["Git_"+normalize(NAMED_GIT_BRANCH)+"_Build_Rh6_Gcc"])
GBRRG = Triggerable(name="Git_"+normalize(NAMED_GIT_BRANCH)+"_Run_Rh6_Gcc",
    builderNames=["Git_"+normalize(NAMED_GIT_BRANCH)+"_Run_Rh6_Gcc"])

# Miscellaneous Scheduler
SDoxyBRG = Nightly(name="Doxygen_Build", 
    hour=21, minute=00, builderNames=["Doxygen_Build"], branch='master')
SCheck = Nightly(name="Check_Datasets", hour=8,
    minute=20, builderNames=["Check_Datasets"], branch='master')

c['schedulers'] = []

#              B U I L D   C O N D I T I O N A L   B L O C K
if BB_DEVEL:
    # Tags
    c['schedulers'].append(SStableBRG)
    c['schedulers'].append(SStableRRG)
    c['schedulers'].append(SBetaBRG)
    c['schedulers'].append(SBetaRRG)  
    #c['schedulers'].append(STagBRG)
    #c['schedulers'].append(STagRRG)  
    # Master Branches
    #c['schedulers'].append(SMBRG)
    #c['schedulers'].append(SMRRG)  
    #c['schedulers'].append(SMBRC)
    #c['schedulers'].append(SMRRC) 
    c['schedulers'].append(GMBRG)
    #c['schedulers'].append(GMRRG)  
    # Named Branches
    c['schedulers'].append(SBBRG)
    c['schedulers'].append(SBRRG)
    c['schedulers'].append(GBBRG)
    c['schedulers'].append(GBRRG)  
    # Miscellaneous Processes
    c['schedulers'].append(SCheck)
    #c['schedulers'].append(SDoxyBRG)
else:
    # Tags
    c['schedulers'].append(SStableBRG)
    c['schedulers'].append(SStableRRG)
    c['schedulers'].append(SBetaBRG)
    c['schedulers'].append(SBetaRRG)  
    c['schedulers'].append(STagBRG)
    c['schedulers'].append(STagRRG)  
    # Master Branches
    c['schedulers'].append(SMBRG)
    c['schedulers'].append(SMRRG)  
    #c['schedulers'].append(SMBRC)
    #c['schedulers'].append(SMRRC) 
    c['schedulers'].append(GMBRG)
    c['schedulers'].append(GMRRG)  
    # Named Branches
    c['schedulers'].append(SBBRG)
    c['schedulers'].append(SBRRG)
    c['schedulers'].append(GBBRG)
    c['schedulers'].append(GBRRG)  
    # Miscellaneous Processes
    c['schedulers'].append(SCheck)
    c['schedulers'].append(SDoxyBRG)

# also remove "c['builders'] = xxxx"  to totally turn off builder use

####### logs
from buildbot.process import factory

from buildbot.steps.shell import ShellCommand, WithProperties
from buildbot.process.properties import Property
from buildbot.steps.slave import RemoveDirectory
from buildbot.status.results import SUCCESS, WARNINGS, FAILURE

class LogFileShellCommand(ShellCommand):
    log_files = []
    log_files.append("config.log")
    log_files.append("build.log")

    def __init__(self, **kwargs):
        # And upcall to let the base class do its work
        ShellCommand.__init__(self, **kwargs)

    def createSummary(self, log):
        for line in log.getText().split("\n"):
            for log_file in self.log_files:
                # line format is "    log file build.log saved to http://dev.lsstcorp.org/...."
                if (line.startswith("log file ") and line.find(" saved to ") >= 0):
                    split = line.split(" saved to ", 1)
                    self.addURL(split[0].split("log file ")[1], split[1])

    def evaluateCommand(self, cmd):
    # Steps should return exit status of 2 to indicate non-fatal warning
        #if self.log_eval_func: 
        #    return self.log_eval_func(cmd, self.step_status) 
        if cmd.rc == 0: 
            return SUCCESS 
        if cmd.rc == 2: 
            return WARNINGS 
        return FAILURE 

class CustomStepShellCommand(LogFileShellCommand):
    def __init__(self, **kwargs):
        # And upcall to let the base class do its work
        LogFileShellCommand.__init__(self, **kwargs)
        self.buildName = "build in progress"

    def createSummary(self, log):
        LogFileShellCommand.createSummary(self, log)
        log_text = log.getText()
        s = re.search("BUILDING_PACKAGE=(.*)", log_text)
        if s:
            self.buildName=s.group(1)

    def describe(self, done=False):
        if self.buildName:
            return [self.buildName]
        return ["???"]


####### CHANGESOURCES

# the 'change_source' setting tells the buildmaster how it should find out
# about source code changes. 

from buildbot.changes.gitpoller import GitPoller
c['change_source'] = []

#  change_source gitpoller:  for master and development branches
#  -------------------------------------------------------------------------
#  N O T E :  Using same list of git packages for both GCC and CLANG stacks
#  -------------------------------------------------------------------------
class PackageList:

    def __init__(self,**kwargs):
        # exclude these packages
        externals = ["sconsUtils"]
        for name in os.listdir(GCCSTACK_EXTERNALS):
            externals.append(name)
        exclude_external_pkgs = set(externals)
        
        # open manifest of lsst stack modules
        stream = open(BUILD_ORDER_MANIFEST,"r")
        
        # read all the packages of the stream, and put them into a set, removing
        # excluded packages and duplicates.
        pkgs = stream.read().split()
        self.pkg_list = []
        pkg_uniq = []
        for name in pkgs:
            if name in pkg_uniq: # skip duplicates
                continue
            pkg_uniq.append(name)
            if (name in exclude_external_pkgs) == False:  # skip exclusions
                self.pkg_list.append(name)
        
    def getPackageList(self):
        return self.pkg_list

# Create list of all non-excluded packages in the git repostiory
p = PackageList()
GIT_PKGS = p.getPackageList()

# take list of unique packages, create a gitPoller for them
for name in GIT_PKGS:
    c['change_source'].append(GitPoller(LSST_DMS+name+".git", 
         workdir="gitpoller_workdir/"+name,
         branch="master", pollinterval=300))
    c['change_source'].append(GitPoller(LSST_DMS+name+".git", 
         workdir="gitpoller_branch_workdir/"+name,
         branch=NAMED_GIT_BRANCH, pollinterval=300))

####### BUILDERS
#
#=============================================================================
# LSST Specifics for each Builder 
#=============================================================================

c['builders'] = []


# -- The following dictionary contains the unique identifiying data for
#    each builder

BD={
   # ................DOXYGEN   - for beta and stable ...................
   'Doxygen_Build': {
      'LSST_HOME' : LSST_HOME_GCC,
      'LSST_DEVEL' : SLAVE_HOME_DIR+'/'+DOXY_SLAVE.split('.')[0]+'/SDoxyBRG/sandbox',             
      'SHORT_BUILD_NAME' : 'SDoxyBRG',
      'SLAVE_HOST' : DOXY_SLAVE,
      'CHOSEN_BRANCH' : 'master',
      'UPDATE_STACK_TAG' : 'beta',
      'CATEGORY' : 'update',
      },
   # ............. Check Status of Online Databases - branch master.......
   'Check_Datasets' : {
      'LSST_HOME' : LSST_HOME_GCC,
      'SHORT_BUILD_NAME'  :  'SCheck',
      'SLAVE_HOST' : CHECK_SLAVE,
      'CATEGORY' : 'update',
      },
   # ........ Nightly Rhel6 GCC Branch Build - branch: master........
   'Master_Build_Rh6_Gcc' : {
      'LSST_HOME' : LSST_HOME_GCC,
      'LSST_DEVEL' : SLAVE_HOME_DIR+'/'+SCHED_MASTER_BUILD_RH6_GCC_SLAVE.split('.')[0]+'/SMBRG/sandbox',                
      'CHOSEN_BRANCH'  :  'master',
      'SHORT_BUILD_NAME'  :  'SMBRG',
      'SLAVE_HOST' : SCHED_MASTER_BUILD_RH6_GCC_SLAVE,
      'TRIGGERABLE_SCHEDULER'  :  SMRRG,
      'UPDATE_STACK_TAG' : 'stable',
      'CCD_COUNT' : DRP_CCD_COUNT_MED,
      'CATEGORY' : 'master',
      },
   #........Triggered Nightly Rhel6 GCC Branch drpRun  - branch: master.....
   'Master_Run_Rh6_Gcc' : {
      'LSST_HOME' : LSST_HOME_GCC,
      'LSST_DEVEL' : SLAVE_HOME_DIR+'/'+SCHED_MASTER_BUILD_RH6_GCC_SLAVE.split('.')[0]+'/SMBRG/sandbox',                
      'CHOSEN_BRANCH'  :  'master',
      'SHORT_BUILD_NAME' : "SMRRG",
      'SLAVE_HOST' : SCHED_MASTER_RUN_RH6_GCC_SLAVE,
      'TRIGGERING_SHORT_BUILD_NAME':"SMBRG",
      'CCD_COUNT' : DRP_CCD_COUNT_MED,
      'CATEGORY' : 'master',
      },
   #......Nightly Rhel6 Clang Branch Build - branch: master......
   'Master_Build_Rh6_Clg' : {
      'LSST_HOME' : LSST_HOME_CLG,
      'LSST_DEVEL': SLAVE_HOME_DIR+"/"+SCHED_MASTER_BUILD_RH6_CLG_SLAVE.split('.')[0]+"/SMBRC/sandbox", 
      'CHOSEN_BRANCH' : "master",
      'SHORT_BUILD_NAME' : "SMBRC",
      'SLAVE_HOST' : SCHED_MASTER_BUILD_RH6_CLG_SLAVE,
      'ENV_EXTRA' : {
         'CC':'clang', 
         'CXX':'clang++', 
         'SCONSFLAGS':'cc=clang',
         },
      'TRIGGERABLE_SCHEDULER' : SMRRC,
      'UPDATE_STACK_TAG' : 'stable',
      'CCD_COUNT' : DRP_CCD_COUNT_SMALL,
      'CATEGORY' : 'master',
      },
   #......Triggered Nightly Rhel6 Clang Branch drpRun  - branch: master.....
   'Master_Run_Rh6_Clg' : {
      'LSST_HOME' : LSST_HOME_CLG,
      'LSST_DEVEL': SLAVE_HOME_DIR+"/"+SCHED_MASTER_BUILD_RH6_CLG_SLAVE.split('.')[0]+"/SMBRC/sandbox", 
      'CHOSEN_BRANCH' : "master",
      'SHORT_BUILD_NAME' : "SMRRC",
      'SLAVE_HOST' : SCHED_MASTER_RUN_RH6_CLG_SLAVE,
      'TRIGGERING_SHORT_BUILD_NAME' : "SMBRC",
      'ENV_EXTRA' : {
         'CC':'clang', 
         'CXX':'clang++', 
         'SCONSFLAGS':'cc=clang',
         },
      'CCD_COUNT' : DRP_CCD_COUNT_MED,
      'CATEGORY' : 'master',
      },
   #.....Nightly Branch Build  - branch: NAMED_GIT_BRANCH.....
   normalize(NAMED_GIT_BRANCH)+"_Build_Rh6_Gcc" : {
      'LSST_HOME' : LSST_HOME_GCC,
      'LSST_DEVEL' :  SLAVE_HOME_DIR+"/"+SCHED_BRANCH_BUILD_RH6_GCC_SLAVE.split('.')[0]+"/SBBRG/sandbox", 
      'CHOSEN_BRANCH' : NAMED_GIT_BRANCH,
      'SHORT_BUILD_NAME' : "SBBRG",
      'SLAVE_HOST' : SCHED_BRANCH_BUILD_RH6_GCC_SLAVE,
      'TRIGGERABLE_SCHEDULER' : SBRRG,
      'UPDATE_STACK_TAG' : 'stable',
      'CCD_COUNT' : DRP_CCD_COUNT_MED,
      'CATEGORY' : 'branch',
      },
   #.....Triggered Nightly Branch Build - branch: NAMED_GIT_BRANCH.....
   normalize(NAMED_GIT_BRANCH)+"_Run_Rh6_Gcc" : {
      'LSST_HOME' : LSST_HOME_GCC,
      'LSST_DEVEL' :  SLAVE_HOME_DIR+"/"+SCHED_BRANCH_BUILD_RH6_GCC_SLAVE.split('.')[0]+"/SBBRG/sandbox", 
      'CHOSEN_BRANCH' : NAMED_GIT_BRANCH,
      'SHORT_BUILD_NAME' : "SBRRG",
      'SLAVE_HOST' : SCHED_BRANCH_RUN_RH6_GCC_SLAVE,
      'TRIGGERING_SHORT_BUILD_NAME' : "SBBRG",
      'CCD_COUNT' : DRP_CCD_COUNT_MED,
      'CATEGORY' : 'branch',
      },
   #.....GitChange Branch Build - branch: master.....
   'Git_Master_Build_Rh6_Gcc' : {
      'LSST_HOME' : LSST_HOME_GCC,
      'LSST_DEVEL' : SLAVE_HOME_DIR+"/"+GIT_MASTER_BUILD_RH6_GCC_SLAVE.split('.')[0]+"/GMBRG/sandbox", 
      'CHOSEN_BRANCH' : "master",
      'SHORT_BUILD_NAME' : "GMBRG",
      'SLAVE_HOST' : GIT_MASTER_BUILD_RH6_GCC_SLAVE,
      'TRIGGERABLE_SCHEDULER' : GMRRG,
      'UPDATE_STACK_TAG' : 'stable',
      'CCD_COUNT' : DRP_CCD_COUNT_SMALL,
      'CATEGORY' : 'master',
      },
   #.....Triggered GitChange Branch drpRun - branch: master.....
   "Git_Master_Run_Rh6_Gcc" : {
      'LSST_HOME' : LSST_HOME_GCC,
      'LSST_DEVEL' : SLAVE_HOME_DIR+"/"+GIT_MASTER_BUILD_RH6_GCC_SLAVE.split('.')[0]+"/GMBRG/sandbox", 
      'CHOSEN_BRANCH' : "master",
      'SHORT_BUILD_NAME' : "GMRRG",
      'SLAVE_HOST' : GIT_MASTER_RUN_RH6_GCC_SLAVE,
      'TRIGGERING_SHORT_BUILD_NAME' : "GMBRG",
      'CCD_COUNT' : DRP_CCD_COUNT_SMALL,
      'CATEGORY' : 'master',
      },
   #.....GitChange Branch Build - branch: NAMED_GIT_BRANCH.....
   'Git_'+normalize(NAMED_GIT_BRANCH)+'_Build_Rh6_Gcc' : {
      'LSST_HOME' : LSST_HOME_GCC,
      'LSST_DEVEL': SLAVE_HOME_DIR+"/"+GIT_BRANCH_BUILD_RH6_GCC_SLAVE.split('.')[0]+"/GBBRG/sandbox", 
      'CHOSEN_BRANCH' : NAMED_GIT_BRANCH,
      'SHORT_BUILD_NAME' : "GBBRG",
      'SLAVE_HOST' : GIT_BRANCH_BUILD_RH6_GCC_SLAVE,
      'TRIGGERABLE_SCHEDULER' : GBRRG,
      'UPDATE_STACK_TAG' : 'stable',
      'CCD_COUNT' : DRP_CCD_COUNT_MED,
      'CATEGORY' : 'branch',
      },
   #.....Triggered GitChange Branch runDrp  - branch: NAMED_GIT_BRANCH.....
   "Git_"+normalize(NAMED_GIT_BRANCH)+"_Run_Rh6_Gcc" : {
      'LSST_HOME' : LSST_HOME_GCC,
      'LSST_DEVEL' : SLAVE_HOME_DIR+"/"+GIT_BRANCH_BUILD_RH6_GCC_SLAVE.split('.')[0]+"/GBBRG/sandbox", 
      'CHOSEN_BRANCH' : NAMED_GIT_BRANCH,
      'SHORT_BUILD_NAME' : 'GBRRG',
      'SLAVE_HOST' : GIT_BRANCH_RUN_RH6_GCC_SLAVE,
      'TRIGGERING_SHORT_BUILD_NAME' : "GBBRG",
      'CCD_COUNT' : DRP_CCD_COUNT_SMALL,
      'CATEGORY' : 'branch',
      },
   #.....Force Rhel6 GCC Branch Build - branch: <user selected>.....
   'User_Branch_Build_Rh6_Gcc' : {
      'LSST_HOME' : LSST_HOME_GCC,
      'LSST_DEVEL': SLAVE_HOME_DIR+"/"+USER_BRANCH_BUILD_RH6_GCC_SLAVE.split('.')[0]+"/FBBRG/sandbox", 
      'CHOSEN_BRANCH' : Property("branch"),
      'SHORT_BUILD_NAME' : "FBBRG",
      'SLAVE_HOST' : USER_BRANCH_BUILD_RH6_GCC_SLAVE,
      'UPDATE_STACK_TAG' : 'stable',
      'CATEGORY' : 'branch',
      },
   #.....Force Rhel6 Clang Branch Build - branch: <user selected>.....
   'User_Branch_Build_Rh6_Clg' : {
      'LSST_HOME' : LSST_HOME_CLG,
      'LSST_DEVEL' : SLAVE_HOME_DIR+"/"+USER_BRANCH_BUILD_RH6_CLG_SLAVE.split('.')[0]+"/FBBRC/sandbox", 
      'CHOSEN_BRANCH' : Property("branch"),
      'SHORT_BUILD_NAME' : "FBBRC",
      'SLAVE_HOST' : USER_BRANCH_BUILD_RH6_CLG_SLAVE,
      'ENV_EXTRA' : {
         'CC' : 'clang', 
         'CXX' : 'clang++', 
         'SCONSFLAGS' : 'cc=clang' 
         },
      'UPDATE_STACK_TAG' : 'stable',
      'CATEGORY' : 'branch',
      },
   #.....Nightly Tag Build - tag: stable.....
   'Stable_Build_Rh6_Gcc' : {
      'LSST_HOME' : LSST_HOME_GCC,
      'LSST_DEVEL' : SLAVE_HOME_DIR+"/"+STABLE_BUILD_RH6_GCC_SLAVE.split('.')[0]+"/SStableBRG/sandbox", 
      'SHORT_BUILD_NAME' : "SStableBRG",
      'SLAVE_HOST' : STABLE_BUILD_RH6_GCC_SLAVE,
      'TAG' : 'stable',
      'TRIGGERABLE_SCHEDULER' : SStableRRG,
      'CCD_COUNT' : DRP_CCD_COUNT_SMALL,
      'CATEGORY' : 'tag',
      },
   #.....Triggered Tag Run  - tag: stable.....
   'Stable_Run_Rh6_Gcc' : {
      'LSST_HOME' : SLAVE_BUILDS_DIR+"/SStableBRG/work",
      'TAG' : 'stable',
      'SHORT_BUILD_NAME' : 'SStableRRG',
      'SLAVE_HOST' : STABLE_RUN_RH6_GCC_SLAVE,
      'TRIGGERING_SHORT_BUILD_NAME' : 'SStableBRG',
      'CATEGORY' : 'tag',
      },
   #.....Nightly Tag Build - tag: beta.....
   'Beta_Build_Rh6_Gcc' : {
      'LSST_HOME' : LSST_HOME_GCC,
      'LSST_DEVEL' : SLAVE_HOME_DIR+"/"+BETA_BUILD_RH6_GCC_SLAVE.split('.')[0]+"/SBetaBRG/sandbox", 
      'SHORT_BUILD_NAME' : "SBetaBRG",
      'SLAVE_HOST' : BETA_BUILD_RH6_GCC_SLAVE,
      'TAG' : 'beta',
      'TRIGGERABLE_SCHEDULER' : SBetaRRG,
      'CCD_COUNT' : DRP_CCD_COUNT_SMALL,
      'CATEGORY' : 'tag',
      },
   #.....Triggered Tag Run  - tag: beta.....
   'Beta_Run_Rh6_Gcc' : {
      'LSST_HOME' : SLAVE_BUILDS_DIR+"/SBetaBRG/work",
      'TAG' : 'beta',
      'SHORT_BUILD_NAME' : 'SBetaRRG',
      'SLAVE_HOST' : BETA_RUN_RH6_GCC_SLAVE,
      'TRIGGERING_SHORT_BUILD_NAME' : 'SBetaBRG',
      'CATEGORY' : 'tag',
      },
   # ............Nightly Tag Build - tag: NAMED_EUPS_TAG..............
   normalize(NAMED_EUPS_TAG)+"_Build_Rh6_Gcc" : {
      'LSST_HOME' : LSST_HOME_GCC,
      'LSST_DEVEL' : SLAVE_HOME_DIR+"/"+NAMED_TAG_BUILD_RH6_GCC_SLAVE.split('.')[0]+"/S"+normalize(NAMED_EUPS_TAG)+"BRG/sandbox", 
      'TAG' : NAMED_EUPS_TAG,
      'TRIGGERABLE_SCHEDULER' : STagRRG,
      'SHORT_BUILD_NAME' : "S"+normalize(NAMED_EUPS_TAG)+"BRG",
      'SLAVE_HOST' : NAMED_TAG_BUILD_RH6_GCC_SLAVE,
      'CCD_COUNT' : DRP_CCD_COUNT_SMALL,
      'CATEGORY' : 'tag',
      },
   # ............Triggered Tag Run  - tag: NAMED_EUPS_TAG..............
   normalize(NAMED_EUPS_TAG)+"_Run_Rh6_Gcc" : {
      'LSST_HOME':SLAVE_BUILDS_DIR+"/S"+normalize(NAMED_EUPS_TAG)+"BRG/work",
      'TAG' : NAMED_EUPS_TAG,
      'SHORT_BUILD_NAME' : "S"+normalize(NAMED_EUPS_TAG)+"RRG",
      'SLAVE_HOST' : NAMED_TAG_RUN_RH6_GCC_SLAVE,
      'TRIGGERING_SHORT_BUILD_NAME' : 'S'+normalize(NAMED_EUPS_TAG)+'BRG',
      'CCD_COUNT' : DRP_CCD_COUNT_SMALL,
      'CATEGORY' : 'tag',
      },
   # .... User_Tag_Build_Rh6_Gcc - tag: <user specified in 'Branch-to-build'>
   'User_Tag_Build_Rh6_Gcc' : {
      'LSST_HOME' : LSST_HOME_GCC,
      'LSST_DEVEL' : SLAVE_HOME_DIR+"/"+USER_TAG_BUILD_RH6_GCC_SLAVE.split('.')[0]+"/FTagBRG/sandbox", 
      'TAG' : Property("branch"),
      'SHORT_BUILD_NAME' : "FTagBRG",
      'SLAVE_HOST' : USER_TAG_BUILD_RH6_GCC_SLAVE,
      'CCD_COUNT' : DRP_CCD_COUNT_SMALL,
      'CATEGORY' : 'tag',
      } ,
   }

if PRINT_TABLE:
   for bldrType, bldrBody in BD.iteritems():
      print ""
      print "------- BD Table ----------------------------------------"
      print bldrType
      print
      for bkey, bvalue in bldrBody.iteritems():
          print "    ",bkey
          print "          ",bvalue 
   print "--------------------------------------------------------"

# 'builders' list defines Builders, which tell Buildbot how to perform a build:
# what steps, and which slaves can execute them.  Note any particular build will
# only take place on one slave.

from buildbot.process import factory
from buildbot.steps.trigger import Trigger

from buildbot.steps.shell import ShellCommand, WithProperties
from buildbot.steps.slave import FileExists


#=============================================================================
#  Generic Build Steps
#=============================================================================
# -- Clear out the old 'work' directory
eraseWorkStep='\
    ShellCommand(\
        name="eraseWorkDir",  description=["eraseWorkDir"],\
        workdir="work", command="rm -rf *; echo Status: $?")'

# -- install tagged stack from tag's manifest list
tagInstallStep='\
    ShellCommand( \
        name="tagInstall", description="tagInstall",\
        env=ENV, timeout=12000, workdir="work", haltOnFailure = True,\
        command=["time", SLAVE_SCRIPTS_DIR + "/run_tagInstall.sh", \
            "--tag", TAG, "--manifest", BUILD_MANIFEST ] )'

# -- Label the Step with the Branch specified
displayBranchStep = '\
    LogFileShellCommand( \
        name="displayBranchName", \
        description=["git- branch/tag:",CHOSEN_BRANCH],\
        env=ENV, workdir="work",\
        command=["time", "echo" , "build branch: ",CHOSEN_BRANCH])'

# -- Label the Step with the Tag specified
displayTagStep = '\
    LogFileShellCommand( \
        name="displayTagName", description=["eups-tag:",TAG],\
        env=ENV, workdir="work",\
        command=["time", "echo" , "build tag: ",TAG])'

# -- update environment
updateBuildbotStep = '\
    LogFileShellCommand( \
        name="updateBuildbot", description="updateBuildbot", \
        env=ENV, workdir="work", haltOnFailure = True,\
        command=["time", SLAVE_SCRIPTS_DIR+"/updateBuildbotEnv.sh", \
            SHARED_ROOT+"/sandbox"])'

# -- update stack
updateStackStep = '\
    LogFileShellCommand( \
        name="updateStack", description="updateStack", \
        env=ENV, timeout=12000, workdir="work", haltOnFailure = True,\
        command=["time", SLAVE_SCRIPTS_DIR+"/gitReleasePackage.sh", \
            "--lsstdir", LSST_HOME, "--no_doxygen", \
            "--tag", UPDATE_STACK_TAG, "lsstactive"])'

# -- build overall manifest
getVersionsStep = '\
    LogFileShellCommand( \
        name="getVersions", description="getVersions", \
        env=ENV, timeout=12000, workdir="work", haltOnFailure = True,\
        command=["time", SLAVE_SCRIPTS_DIR + "/bootstrap.sh",\
            "--debug", "--branch", CHOSEN_BRANCH, \
            "--excluded", EXCLUDED_GIT_REPOSTIORIES,\
            "--builder_name", Property("buildername"),\
            "--build_number", Property("buildnumber")])'

# -- acquire packages in manifest
preparePackagesStep = '\
    LogFileShellCommand( \
        name="preparePackages", description="preparePackages",\
        env=ENV, timeout=12000, workdir="work", haltOnFailure = True,\
        command=["time", SLAVE_SCRIPTS_DIR + "/prepareManifestPackages.sh",\
            "--debug", "--step_name","prepare_packages", \
            "--branch", CHOSEN_BRANCH,\
            "--builder_name", Property("buildername"),\
            "--build_number", Property("buildnumber")])'

# -- declare packages in manifest
declarePackagesStep = '\
    LogFileShellCommand( \
        name="declarePackages", description="declarePackages", \
        env=ENV, timeout=12000, workdir="work", haltOnFailure = True,\
        command=["time", SLAVE_SCRIPTS_DIR + "/declareAllPackages.sh",\
            "--debug", "--branch", CHOSEN_BRANCH, \
            "--builder_name", Property("buildername"),\
            "--build_number", Property("buildnumber")]) '

# -- build package  manifest lists
extractDependenciesStep = '\
    LogFileShellCommand( \
        name="extractDependencies", description="extractDependencies",\
        env=ENV, timeout=12000, workdir="work", haltOnFailure=True,\
        command=["time",SLAVE_SCRIPTS_DIR + "/dependencies.sh",\
            "--debug", "--branch", CHOSEN_BRANCH, \
            "--builder_name", Property("buildername"),\
            "--build_number", Property("buildnumber"), \
            "beta stable"])'

# -- build OnChange package
# following package is scm-event driven, thus on_change tag
buildOnChangeStep = '\
    LogFileShellCommand( \
        name="buildOnChange", description=Property("repository"),\
        env=ENV, timeout=12000, workdir="work",\
        command=["time", SLAVE_SCRIPTS_DIR+"/gitBuild.sh",\
            "--debug", "--step_name", STEP_NAME,\
            "--parallel", 2, PACKAGE_BUILD_TYPE,\
            "--log_dest", BUILDLOG_DEST, "--log_url", BUILDLOG_URL,\
            "--builder_name", Property("buildername"),\
            "--build_number", Property("buildnumber"),\
            Property("repository") ])'

# -- build manifest package ... to be used in loop over all packages, e.g.
# for name in GIT_PKGS:
buildScmPackageStep = '\
    LogFileShellCommand( \
        name=name, description=name,\
        env=ENV, timeout=12000, workdir="work",\
        command=["time", SLAVE_SCRIPTS_DIR + "/gitBuild.sh",\
            "--debug", "--step_name", STEP_NAME,\
            "--parallel", 2, PACKAGE_BUILD_TYPE,\
            "--log_dest", BUILDLOG_DEST, "--log_url", BUILDLOG_URL,\
            "--builder_name", Property("buildername"),\
            "--build_number", Property("buildnumber"),\
            name ])'

# -- Save manifest for successful run
saveDependencyManifestStep = '\
    LogFileShellCommand( \
        name="saveManifest", description="saveManifest",\
        env=ENV, timeout=12000, workdir="work",\
        haltOnFailure = True,\
        command=["time", SLAVE_SCRIPTS_DIR + "/saveDependencyManifest.sh",\
            "--debug", "--package", "datarel",\
            "--builder_name", Property("buildername"),\
            "--build_number", Property("buildnumber")])'

# -- trigger production run buildslave
triggerDrpRunStep = '\
    Trigger(schedulerNames=[TRIGGERABLE_SCHEDULER.name], waitForFinish=True)'

# -- Initiate selectable-dataset Integration Test Run
#   NOT USED YET _ PLANNED TO INVOKE selectable: runDrp, runDrpSdss, demo
drpRunCollectionStep = '\
    LogFileShellCommand( \
        name="drpRunCollection", description="drpRunCollection",\
        env=ENV, timeout=None,  workdir="work",\
        warnOnWarnings = True,\
        command=["time",SLAVE_SCRIPTS_DIR + "/botRunProduction.sh",\
            "--debug", "--ccd_count", CCD_COUNT, \
            "--collection", COLLECTION, "--manifest", BUILD_MANIFEST,\
            "--input_data", DRP_INPUT_DATA, \
            "--astro_net_data", DRP_ASTRO_NET_DATA,\
            "--builder_name", Property("buildername"),\
            "--build_number", Property("buildnumber")])'

# -- Initiate drpRun Integration Test Run
drpRunStep = '\
    LogFileShellCommand( \
        name="drpRun", description="drpRun",\
        env=ENV, timeout=None,  workdir="work",\
        warnOnWarnings = True,\
        command=["time",SLAVE_SCRIPTS_DIR + "/botRunProduction.sh",\
            "--debug", "--ccd_count", CCD_COUNT, "--manifest", BUILD_MANIFEST,\
            "--input_data", DRP_INPUT_DATA, \
            "--astro_net_data", DRP_ASTRO_NET_DATA,\
            "--builder_name", Property("buildername"),\
            "--build_number", Property("buildnumber")])'

# -- Initiate demo Integration Test Run
demoRunStep = '\
    LogFileShellCommand( \
        name="demoRun", description="demoRun",\
        env=ENV, timeout=None,  workdir="work",\
        warnOnWarnings = True,\
        command=["time",SLAVE_SCRIPTS_DIR + "/botRunDemo.sh",\
            "--debug", "--manifest", BUILD_MANIFEST,\
            "--builder_name", Property("buildername"),\
            "--build_number", Property("buildnumber")])'

# -- build doxygen documentation for master
buildDoxydocStep =  '\
    LogFileShellCommand(  \
        name="doxydoc", description="doxydoc",\
        env=ENV, timeout=12000,  workdir="work",\
        command=["time", SLAVE_SCRIPTS_DIR+"/generateDoxyDoc.sh",\
            "--package", "datarel", "--doxygen_dest", DOXY_DEST,\
            "--doxygen_url", DOXY_URL, "--branch", CHOSEN_BRANCH])'

# -- check that on-disk versions of git data repositories are up-to-date
# for ds, props in DATASETS.iteritems():
#    SHORT_DS_NAME = ds
checkDatasetCurrentStep = '\
    LogFileShellCommand(  \
        name=SHORT_DS_NAME, description=SHORT_DS_NAME,\
        env=ENV, timeout=1200, workdir="work", flunkOnWarnings=True, \
        command=["time", SLAVE_SCRIPTS_DIR + "/checkDatasetCurrent.sh",\
            "--name", SHORT_DS_NAME, "--gitname", GIT_DS, "--path", DISK_DS ])'

# -- check etc/LsstStackManifest.list == builds/SMBRG/work/BuildOrderMnaifest
checkMasterDependencyStep = '\
    LogFileShellCommand( \
        name="LsstStackManifest", description="LsstStackManifest",\
        env=ENV, timeout=1200, workdir="work", flunkOnWarnings=True, \
        command=["time", SLAVE_SCRIPTS_DIR + "/checkStackDependencyOrder.sh",\
            "--master", BUILD_ORDER_MANIFEST, \
            "--nightly", NIGHTLY_BUILD_ORDER_MANIFEST, ])'


# -- check drp locks aren't abandoned
checkDrpLocksStep = '\
    LogFileShellCommand( \
        name="DrpLocks", description="DrpLocks",\
        env=ENV, timeout=1200, workdir="work", flunkOnFailure=True, \
        command=["time", SLAVE_SCRIPTS_DIR + "/checkDrpLocks.sh" ])'


def print_table( builderList, builderEnv):
      print ""
      for bldrType in builderList:
         print "====== Builder Instance ================================"
         print bldrType
         print
         for bkey, bvalue in BD[bldrType].iteritems():
             print "    ",bkey
             print "          ",bvalue 
      print "--------------------------------------------------------"
      print "ENV: "
      for bkey, bvalue in builderEnv.iteritems():
             print "    ",bkey
             print "          ",bvalue 
#=============================================================================
#         B R A N C H E S    B R A N C H E S    B R A N C H E S
#=============================================================================
#  builder:     Nightly Master Build Rhel6 GCC   Branch Build 
#  builder:     Nightly Master Build Rhel6 Clang Branch Build 
#  builder:     Nightly Branch Build Rhel6 GCC - branch: NAMED_GIT_BRANCH
#=============================================================================

    #RAA extracted CLANG from builder list below
    #('Master_Build_Rh6_Clg','Master_Run_Rh6_Clg'),\
for gitbld,gitrun in \
    ('Master_Build_Rh6_Gcc','Master_Run_Rh6_Gcc'),\
    (normalize(NAMED_GIT_BRANCH)+"_Build_Rh6_Gcc",normalize(NAMED_GIT_BRANCH)+"_Run_Rh6_Gcc"):
   BUILDER_NAME = gitbld
   LSST_HOME = BD[gitbld]['LSST_HOME']
   CHOSEN_BRANCH = BD[gitbld]['CHOSEN_BRANCH']
   SHORT_BUILD_NAME = BD[gitbld]['SHORT_BUILD_NAME']
   TRIGGERABLE_SCHEDULER = BD[gitbld]['TRIGGERABLE_SCHEDULER']
   UPDATE_STACK_TAG = BD[gitbld]['UPDATE_STACK_TAG']
   CCD_COUNT = BD[gitbld]['CCD_COUNT']

   SHARED_ROOT = SLAVE_HOME_DIR+'/'+BD[gitbld]['SLAVE_HOST'].split('.')[0]+'/'+SHORT_BUILD_NAME
   ENV = {
      'LSST_HOME' : LSST_HOME,
      'EUPS_USERDATA' : SHARED_ROOT+'/eups_userdata'
      }
   if BD[gitbld].has_key('LSST_DEVEL'): ENV.update({'LSST_DEVEL':BD[gitbld]['LSST_DEVEL']})
   if BD[gitbld].has_key('ENV_EXTRA'): 
       for k in BD[gitbld]['ENV_EXTRA'].keys(): ENV[k] = BD[gitbld]['ENV_EXTRA'][k]
   BUILD_MANIFEST = SLAVE_BUILDS_DIR+'/'+SHORT_BUILD_NAME+'/'+SUCCESSFUL_BUILD_MANIFEST
   if PRINT_TABLE: print_table( [gitbld, gitrun], ENV )

   f = factory.BuildFactory()
   f.addStep( eval(displayBranchStep))
   f.addStep( eval(updateBuildbotStep))
   f.addStep( eval(updateStackStep))
   f.addStep( eval(getVersionsStep))
   f.addStep( eval(preparePackagesStep))
   f.addStep( eval(declarePackagesStep))
   f.addStep( eval(extractDependenciesStep))
   # Following line is a dummy so all builders can use same Step definition
   PACKAGE_BUILD_TYPE="--debug"
   for name in GIT_PKGS:
       STEP_NAME=name
       f.addStep( eval( buildScmPackageStep))
   f.addStep( eval(buildDoxydocStep))
   f.addStep( eval(saveDependencyManifestStep))

   #  Replace in-line drpRunStep w/ trigger line if this slave is VM
   f.addStep(eval(triggerDrpRunStep))
   # f.addStep( eval(drpRunStep))

   c['builders'].append( { 'name': BUILDER_NAME,
           'slavename': BD[gitbld]['SLAVE_HOST'],
           'builddir': SLAVE_BUILDS_DIR+"/"+SHORT_BUILD_NAME,
           'factory': f,
           'properties': {'branch':CHOSEN_BRANCH},
           'category':  BD[gitbld]['CATEGORY'],
           } )

   #=========================================================================
   #  builder:     Triggered Nightly Master Run Rhel6 GCC   
   #  builder:     Triggered Nightly Master Run Rhel6 Clang 
   #  builder:     Triggered Nightly Branch Run - branch: NAMED_GIT_BRANCH
   #=========================================================================
   # Triggered slaves use definitions from Triggering slave in same code block
   BUILDER_NAME = gitrun
   SHORT_BUILD_NAME = BD[gitrun]['SHORT_BUILD_NAME']
   TRIGGERING_SHORT_BUILD_NAME = BD[gitrun]['TRIGGERING_SHORT_BUILD_NAME']

   f = factory.BuildFactory()
   f.addStep( eval(displayBranchStep))
   f.addStep( FileExists( file=BUILD_MANIFEST, haltOnFailure = True))
   f.addStep( eval(drpRunStep))

   # Note that triggered builddir must be different from Triggering builddir
   c['builders'].append( { 'name': BUILDER_NAME,
           'slavename': BD[gitrun]['SLAVE_HOST'],
           'builddir': SLAVE_BUILDS_DIR+"/"+SHORT_BUILD_NAME,
           'factory': f,
           'properties': {'branch':CHOSEN_BRANCH},
           'category': BD[gitrun]['CATEGORY'],
           } )

#===========================================================================
#  builder:     GitChange Branch Build - branch: master
#  builder:     GitChange Branch Build - branch: NAMED_GIT_BRANCH
#===========================================================================
for gitbld,gitrun in \
    ('Git_Master_Build_Rh6_Gcc','Git_Master_Run_Rh6_Gcc'),\
    ('Git_'+normalize(NAMED_GIT_BRANCH)+'_Build_Rh6_Gcc','Git_'+normalize(NAMED_GIT_BRANCH)+'_Run_Rh6_Gcc'):
   BUILDER_NAME = gitbld
   LSST_HOME = BD[gitbld]['LSST_HOME']
   CHOSEN_BRANCH = BD[gitbld]['CHOSEN_BRANCH']
   SHORT_BUILD_NAME = BD[gitbld]['SHORT_BUILD_NAME']
   TRIGGERABLE_SCHEDULER = BD[gitbld]['TRIGGERABLE_SCHEDULER']
   UPDATE_STACK_TAG = BD[gitbld]['UPDATE_STACK_TAG']
   CCD_COUNT = BD[gitbld]['CCD_COUNT']
   
   SHARED_ROOT = SLAVE_HOME_DIR+'/'+BD[gitbld]['SLAVE_HOST'].split('.')[0]+'/'+SHORT_BUILD_NAME
   ENV = {
      'LSST_HOME' : LSST_HOME,
      'EUPS_USERDATA' : SHARED_ROOT+'/eups_userdata'
      }
   if BD[gitbld].has_key('LSST_DEVEL'): ENV.update({'LSST_DEVEL':BD[gitbld]['LSST_DEVEL']})
   if BD[gitbld].has_key('ENV_EXTRA'): 
       for k in BD[gitbld]['ENV_EXTRA'].keys(): ENV[k] = BD[gitbld]['ENV_EXTRA'][k]
   if PRINT_TABLE: print_table( [gitbld, gitrun], ENV )



   BUILD_MANIFEST = SLAVE_BUILDS_DIR+'/'+SHORT_BUILD_NAME+'/'+SUCCESSFUL_BUILD_MANIFEST
   
   f = factory.BuildFactory()
   f.addStep(eval(displayBranchStep))
   f.addStep(eval(updateBuildbotStep))
   f.addStep(eval(updateStackStep))
   f.addStep(eval(getVersionsStep))
   f.addStep(eval(preparePackagesStep))
   f.addStep(eval(declarePackagesStep))
   f.addStep(eval(extractDependenciesStep))
   PACKAGE_BUILD_TYPE="--on_change"
   STEP_NAME="Build_On_Change"
   f.addStep(eval(buildOnChangeStep))
   PACKAGE_BUILD_TYPE="--on_demand"
   STEP_NAME=name
   for name in PRODUCTION_PACKAGE_ROOTS:
           f.addStep(eval(buildScmPackageStep))
   f.addStep(eval(saveDependencyManifestStep))
   
   #  TBD :  Replace in-line drpRunStep w/ trigger line if this slave is VM
   f.addStep(eval(triggerDrpRunStep))
   # f.addStep( eval(drpRunStep))
   
   c['builders'].append( { 'name': BUILDER_NAME,
           'slavename': BD[gitbld]['SLAVE_HOST'],
           'builddir': SLAVE_BUILDS_DIR+"/"+SHORT_BUILD_NAME,
           'factory': f,
           'properties': {'branch':CHOSEN_BRANCH},
           'category':  BD[gitbld]['CATEGORY'],
           } )

   #=======================================================================
   #  builder:     Triggered GitChange Branch drpRun - branch: master
   #  builder:     Triggered GitChange Branch runDrp  - branch: NAMED_GIT_BRANCH
   #=======================================================================
   BUILDER_NAME = gitrun
   SHORT_BUILD_NAME = BD[gitrun]['SHORT_BUILD_NAME']
   TRIGGERING_SHORT_BUILD_NAME = BD[gitrun]['TRIGGERING_SHORT_BUILD_NAME']
   
   f = factory.BuildFactory()
   f.addStep( eval(displayBranchStep))
   f.addStep( FileExists( file=BUILD_MANIFEST, haltOnFailure = True))
   f.addStep( eval(drpRunStep))
   
   # Note that builddir must be different from Trigger slave
   c['builders'].append( { 'name': BUILDER_NAME,
           'slavename': BD[gitrun]['SLAVE_HOST'],
           'builddir': SLAVE_BUILDS_DIR+"/"+SHORT_BUILD_NAME,
           'factory': f,
           'properties': {'branch':CHOSEN_BRANCH},
           'category': BD[gitrun]['CATEGORY'],
           } )


#=============================================================================
#  builder:     Force Rhel6 GCC   Branch Build - branch: <user selected>
#  builder:     Force Rhel6 Clang Branch Build - branch: <user selected>
#=============================================================================
# ---------------------------
# this is for forced build of a branch but not including its production run
# You MUST fill out the Forced Branch Build form field: "branch" 
# with either git-branch, e.g. tickets/1934, or git-tag, e.g. Winter2012d.
# ---------------------------
    #RAA extracted CLANG from builder list below
    #RAA for gitbld in ('User_Branch_Build_Rh6_Gcc','User_Branch_Build_Rh6_Clg'):
gitbld = 'User_Branch_Build_Rh6_Gcc'
if True:
   BUILDER_NAME = gitbld
   LSST_HOME = BD[gitbld]['LSST_HOME']
   CHOSEN_BRANCH = BD[gitbld]['CHOSEN_BRANCH']
   SHORT_BUILD_NAME = BD[gitbld]['SHORT_BUILD_NAME']
   UPDATE_STACK_TAG = BD[gitbld]['UPDATE_STACK_TAG']
   
   SHARED_ROOT = SLAVE_HOME_DIR+'/'+BD[gitbld]['SLAVE_HOST'].split('.')[0]+'/'+SHORT_BUILD_NAME
   ENV = {
      'LSST_HOME' : LSST_HOME,
      'EUPS_USERDATA' : SHARED_ROOT+'/eups_userdata'
      }
   if BD[gitbld].has_key('LSST_DEVEL'): ENV.update({'LSST_DEVEL':BD[gitbld]['LSST_DEVEL']})
   if BD[gitbld].has_key('ENV_EXTRA'):
       for k in BD[gitbld]['ENV_EXTRA'].keys(): ENV[k] = BD[gitbld]['ENV_EXTRA'][k]
   BUILD_MANIFEST = SLAVE_BUILDS_DIR+'/'+SHORT_BUILD_NAME+'/'+SUCCESSFUL_BUILD_MANIFEST
   if PRINT_TABLE: print_table( [gitbld], ENV )

   f = factory.BuildFactory()
   f.addStep( eval( displayBranchStep ))
   f.addStep(RemoveDirectory(dir=SHARED_ROOT+"/eups_userdata"))
   f.addStep(RemoveDirectory(dir=SHARED_ROOT+"/sandbox"))
   f.addStep( eval(eraseWorkStep))
   f.addStep( eval(updateBuildbotStep))
   f.addStep( eval(updateStackStep))
   f.addStep( eval(getVersionsStep))
   f.addStep( eval(preparePackagesStep))
   f.addStep( eval(declarePackagesStep))
   f.addStep( eval(extractDependenciesStep))
   
   #   Following packages are specified on_demand since not scm-event-driven.
   #   Step_name set to prevent sending error msg to these pkg's guru on error.
   PACKAGE_BUILD_TYPE="--on_demand"
   STEP_NAME="on_demand_build"
   for name in PRODUCTION_PACKAGE_ROOTS:
       f.addStep( eval(buildScmPackageStep))
   f.addStep( eval(saveDependencyManifestStep))

   c['builders'].append( { 'name': BUILDER_NAME,
       'slavename': BD[gitbld]['SLAVE_HOST'],
       'builddir': SLAVE_BUILDS_DIR+"/"+SHORT_BUILD_NAME,
       'factory': f,
       #'properties': {'branch':CHOSEN_BRANCH}, .... already set via form
       'category':  BD[gitbld]['CATEGORY'],
       } )
 
#=============================================================================
#                   T A G S     T A G S      T A G S
#=============================================================================
#  builder:     Nightly Tag Build - tag: stable
#  builder:     Nightly Tag Build - tag: beta
#  builder:     Nightly Tag Build - tag: NAMED_EUPS_TAG
#=============================================================================
for gitbld, gitrun in \
    ('Stable_Build_Rh6_Gcc','Stable_Run_Rh6_Gcc'),\
    ('Beta_Build_Rh6_Gcc','Beta_Run_Rh6_Gcc'),\
    (normalize(NAMED_EUPS_TAG)+"_Build_Rh6_Gcc",normalize(NAMED_EUPS_TAG)+"_Run_Rh6_Gcc"):
   BUILDER_NAME = gitbld
   LSST_HOME = BD[gitbld]['LSST_HOME']
   SHORT_BUILD_NAME = BD[gitbld]['SHORT_BUILD_NAME']
   TAG = BD[gitbld]['TAG']
   CCD_COUNT = BD[gitbld]['CCD_COUNT']

   TRIGGERABLE_SCHEDULER = BD[gitbld]['TRIGGERABLE_SCHEDULER']
   SHARED_ROOT = SLAVE_HOME_DIR+'/'+BD[gitbld]['SLAVE_HOST'].split('.')[0]+'/'+SHORT_BUILD_NAME
   ENV = {
      'LSST_HOME' : LSST_HOME,
      'EUPS_USERDATA' : SHARED_ROOT+'/eups_userdata'
      }
   if BD[gitbld].has_key('LSST_DEVEL'): ENV.update({'LSST_DEVEL':BD[gitbld]['LSST_DEVEL']})
   if BD[gitbld].has_key('ENV_EXTRA'):
       for k in BD[gitbld]['ENV_EXTRA'].keys(): ENV[k] = BD[gitbld]['ENV_EXTRA'][k]

   BUILD_MANIFEST = SLAVE_BUILDS_DIR+'/'+SHORT_BUILD_NAME+'/'+SUCCESSFUL_BUILD_MANIFEST
   if PRINT_TABLE: print_table( [gitbld, gitrun], ENV )
   
   f = factory.BuildFactory()
   f.addStep( eval(displayTagStep))
   f.addStep( eval(updateBuildbotStep))  
   f.addStep( eval(eraseWorkStep))
   f.addStep( eval(tagInstallStep))
   #  TBD :  Replace in-line drpRunStep w/ trigger line if this slave is VM
   f.addStep(eval(triggerDrpRunStep))
   # f.addStep( eval(drpRunStep))

   c['builders'].append( { 'name': BUILDER_NAME,
           'slavename': BD[gitbld]['SLAVE_HOST'],
           'builddir': SLAVE_BUILDS_DIR+"/"+SHORT_BUILD_NAME,
           'factory': f,
           'properties' : {'tag':TAG},
           'category':  BD[gitbld]['CATEGORY'],
           } )
   #========================================================================
   #  builder:     Triggered Tag Run  - tag: stable
   #  builder:     Triggered Tag Run  - tag: beta
   #  builder:     Triggered Tag Run  - tag: NAMED_EUPS_TAG
   #========================================================================
   BUILDER_NAME = gitrun
   SHORT_BUILD_NAME = BD[gitrun]['SHORT_BUILD_NAME']
   TRIGGERING_SHORT_BUILD_NAME = BD[gitrun]['TRIGGERING_SHORT_BUILD_NAME']

   f = factory.BuildFactory()
   f.addStep( eval(displayTagStep))
   f.addStep( eval(updateBuildbotStep))
   f.addStep( FileExists( file=BUILD_MANIFEST, haltOnFailure = True))
   f.addStep( eval(drpRunStep))

   # Note that builddir must be different from Trigger slave
   c['builders'].append( { 'name': BUILDER_NAME,
           'slavename': BD[gitrun]['SLAVE_HOST'],
           'builddir': SLAVE_BUILDS_DIR+"/"+SHORT_BUILD_NAME,
           'factory': f,
           'properties' : {'tag':TAG},
           'category': BD[gitrun]['CATEGORY'],
           } )

#=============================================================================
#  builder:   User_Tag_Build_Rh6_Gcc - tag: <user specified in 'Branch-to-build:'>
#=============================================================================
gitbld = 'User_Tag_Build_Rh6_Gcc'
BUILDER_NAME = gitbld
LSST_HOME = BD[gitbld]['LSST_HOME']
SHORT_BUILD_NAME = BD[gitbld]['SHORT_BUILD_NAME']
TAG = BD[gitbld]['TAG']
CCD_COUNT = BD[gitbld]['CCD_COUNT']

SHARED_ROOT = SLAVE_HOME_DIR+'/'+BD[gitbld]['SLAVE_HOST'].split('.')[0]+'/'+SHORT_BUILD_NAME
ENV = {
    'LSST_HOME' : LSST_HOME,
    'EUPS_USERDATA' : SHARED_ROOT+'/eups_userdata'
    }
if BD[gitbld].has_key('LSST_DEVEL'): ENV.update({'LSST_DEVEL':BD[gitbld]['LSST_DEVEL']})
if BD[gitbld].has_key('ENV_EXTRA'):
    for k in BD[gitbld]['ENV_EXTRA'].keys(): ENV[k] = BD[gitbld]['ENV_EXTRA'][k]

BUILD_MANIFEST = SLAVE_BUILDS_DIR+'/'+SHORT_BUILD_NAME+'/'+SUCCESSFUL_BUILD_MANIFEST
if PRINT_TABLE: print_table( [gitbld], ENV )

f = factory.BuildFactory()
f.addStep( eval( displayTagStep ))
f.addStep( eval(updateBuildbotStep))  
f.addStep( eval(eraseWorkStep))
f.addStep( eval(tagInstallStep))
f.addStep( FileExists( file=BUILD_MANIFEST, haltOnFailure = True))
f.addStep( eval( drpRunStep))

c['builders'].append( { 'name': BUILDER_NAME,
   'slavename': BD[gitbld]['SLAVE_HOST'],
   'builddir': SLAVE_BUILDS_DIR+"/"+SHORT_BUILD_NAME,
   'factory': f,
   'properties' : {'tag':TAG},
   'category':  BD[gitbld]['CATEGORY'],
   } )

#=============================================================================
#  builder:     DOXYGEN   - beta and stable
#=============================================================================
gitbld = 'Doxygen_Build'
BUILDER_NAME = gitbld
LSST_HOME = BD[gitbld]['LSST_HOME']
CHOSEN_BRANCH = BD[gitbld]['CHOSEN_BRANCH']
SHORT_BUILD_NAME = BD[gitbld]['SHORT_BUILD_NAME']
UPDATE_STACK_TAG=BD[gitbld]['UPDATE_STACK_TAG']

SHARED_ROOT = SLAVE_HOME_DIR+'/'+BD[gitbld]['SLAVE_HOST'].split('.')[0]+'/'+SHORT_BUILD_NAME
ENV = {
      'LSST_HOME' : LSST_HOME,
      'EUPS_USERDATA' : SHARED_ROOT+'/eups_userdata'
      }
if BD[gitbld].has_key('LSST_DEVEL'): ENV.update({'LSST_DEVEL':BD[gitbld]['LSST_DEVEL']})
if BD[gitbld].has_key('ENV_EXTRA'):
    for k in BD[gitbld]['ENV_EXTRA'].keys(): ENV[k] = BD[gitbld]['ENV_EXTRA'][k]
if PRINT_TABLE: print_table( [gitbld], ENV )

f = factory.BuildFactory()
f.addStep( eval(updateBuildbotStep))
f.addStep( eval(updateStackStep))

# -- build stable doxygen
f.addStep( LogFileShellCommand( description=["stableDoxygen"],
   name="stableDoxygen", env=ENV, timeout=12000, workdir="work",
   command=["time", SLAVE_SCRIPTS_DIR+"/create_xlinkdocs.sh", "stable",
   DOXY_DEST, DOXY_URL]))

# -- build beta doxygen
f.addStep( LogFileShellCommand( description=["betaDoxygen"],
   name="betaDoxygen", env=ENV, timeout=12000, workdir="work",
   command=["time", SLAVE_SCRIPTS_DIR+"/create_xlinkdocs.sh", "beta",
   DOXY_DEST, DOXY_URL]))

c['builders'].append( { 'name': BUILDER_NAME,
   'slavename': BD[gitbld]['SLAVE_HOST'],
   'builddir': SLAVE_BUILDS_DIR+"/"+SHORT_BUILD_NAME,
   'factory': f,
   'category':  BD[gitbld]['CATEGORY'],
   } )


#=============================================================================
#  builder:     Check Status of Online Databases - branch master
#=============================================================================
gitbld = 'Check_Datasets'
BUILDER_NAME = gitbld
LSST_HOME = BD[gitbld]['LSST_HOME']
SLAVE_HOST = BD[gitbld]['SLAVE_HOST']
SHORT_BUILD_NAME = BD[gitbld]['SHORT_BUILD_NAME']

SHARED_ROOT = SLAVE_HOME_DIR+"/"+SLAVE_HOST.split('.')[0]+"/"+SHORT_BUILD_NAME
ENV = {
      'LSST_HOME' : LSST_HOME,
      'EUPS_USERDATA' : SHARED_ROOT+'/eups_userdata',
      }
if BD[gitbld].has_key('LSST_DEVEL'): ENV.update({'LSST_DEVEL':BD[gitbld]['LSST_DEVEL']})
if BD[gitbld].has_key('ENV_EXTRA'):
    for k in BD[gitbld]['ENV_EXTRA'].keys(): ENV[k] = BD[gitbld]['ENV_EXTRA'][k]
if PRINT_TABLE: print_table( [gitbld], ENV )

f = factory.BuildFactory()
for ds, props in DATASETS.iteritems():
    SHORT_DS_NAME = ds
    GIT_DS = props[0]
    DISK_DS = props[1]

    # construct the steps
    f.addStep( eval( checkDatasetCurrentStep ))

f.addStep( eval( checkMasterDependencyStep ))
f.addStep( eval( checkDrpLocksStep ))

c['builders'].append( { 'name': BUILDER_NAME,
        'slavename': SLAVE_HOST,
        'builddir': SLAVE_BUILDS_DIR+"/"+SHORT_BUILD_NAME,
        'factory': f,
        'category': BD[gitbld]['CATEGORY'] 
        })

#=============================================================================
#=============================================================================
#  Final Setup for Buildbot Master
#=============================================================================

####### STATUS TARGETS

# 'status' is a list of Status Targets. The results of each build will be
# pushed to these targets. buildbot/status/*.py has a variety to choose from,
# including web pages, email senders, and IRC bots.

from buildbot.status.builder import Results
import cgi, datetime
import smtplib


c['status'] = []

#-- Send Build Status via email

# Build the Body of the email message used by most of the formatters
def update_mailBody(mode, name, build, results, master_status, dm_blame_list):
    result = Results[results]
    buildProperties = build.getProperties()
    buildNumber = buildProperties['buildnumber']
    buildSlaveHostName = build.getSlavename()
    shortSlaveHostName, dummy = buildSlaveHostName.split('.',1)
 
    buildHome = BD[name]['LSST_HOME']
    buildSandbox = "%s/%s/%s/sandbox" %(SLAVE_HOME_DIR, shortSlaveHostName, BD[name]['SHORT_BUILD_NAME'])
    workDir = "%s/%s/work" %(SLAVE_BUILDS_DIR, BD[name]['SHORT_BUILD_NAME'])
    dummy, language = name.rsplit('_',1)
    if language == "Gcc": buildLanguage = "gcc"
    elif language == "Clg": buildLanguage = "clang"
    else: buildLanguage = ""
    if BD[name].has_key('LSST_DEVEL'):
        eupsPath = "%s:%s" %(buildSandbox, buildHome)
    else:
        eupsPath = buildHome

    limit_lines = 15
    address_list = ", ".join(dm_blame_list).translate(maketrans("<>","[]"))
    text = list()
    text.append(u'<h4>Build status: %s</h4>' % result.upper())
    text.append(u'<table cellspacing="10"><tr>')
    text.append(u"<td>Build Name:</td><td><b>%s</b></td></tr>" % name)
    text.append(u"<td>Short Build Name:</td><td><b>%s</b></td></tr>" % BD[name]['SHORT_BUILD_NAME'])
    text.append(u"<td>Build Number:</td><td><b>%s</b></td></tr>" % buildNumber)
    text.append(u"<td>Buildslave:</td><td><b>%s</b></td></tr>" % buildSlaveHostName)
    text.append(u"<td>Build Home:</td><td><b>%s</b></td></tr>" % buildHome)
    text.append(u"<td>Build Sandbox:</td><td><b>%s</b></td></tr>" % buildSandbox)
    text.append(u"<td>Short Slave Name:</td><td><b>%s</b></td></tr>" % shortSlaveHostName)

    # Skip the info on setup recreating the environment during the failure
    if buildLanguage != "":
        text.append(u"<td>Compilation Language: </td><td><b>%s</b></td></tr>" % buildLanguage)
    text.append(u"<td>Eups Path:</td><td><b>%s</b></td></tr>" % eupsPath)
    text.append(u"<td>Work Directory:</td><td><b>%s</b></td></tr>" % workDir)
    if master_status.getURLForThing(build):
        text.append(u'<tr><td>Complete logs for all build steps:</td><td><a href="%s">%s</a></td></tr>'
                    % (master_status.getURLForThing(build),
                       master_status.getURLForThing(build))
                    )
        text.append(u'<tr><td>Build Reason:</td><td>%s</td></tr>' % build.getReason())
        source = u""
        ss = build.getSourceStamp()
        if ss.branch:
            source += u"[branch %s] " % ss.branch
        if ss.revision:
            source +=  ss.revision
        else:
            source += u"HEAD"
        if ss.patch:
            source += u" (plus patch)"
        if ss.patch_info: # add patch comment
            source += u" (%s)" % ss.patch_info[1]
        text.append(u"<tr><td>Build Source Stamp:</td><td><b>%s</b></td></tr>" % source)
        text.append(u"<tr><td>Blamelist:</td><td>%s</td></tr>" % address_list)
        text.append(u'</table>')
        if ss.changes:
            text.append(u'<h4>Recent Changes:</h4>')
            for c in ss.changes:
                cd = c.asDict()
                when = datetime.datetime.fromtimestamp(cd['when'] ).ctime()
                text.append(u'<table cellspacing="10">')
                text.append(u'<tr><td>Repository:</td><td>%s</td></tr>' % cd['repository'] )
                text.append(u'<tr><td>Project:</td><td>%s</td></tr>' % cd['project'] )
                text.append(u'<tr><td>Time:</td><td>%s</td></tr>' % when)
                text.append(u'<tr><td>Changed by:</td><td>%s</td></tr>' % cd['who'] )
                text.append(u'<tr><td>Comments:</td><td>%s</td></tr>' % cd['comments'] )
                text.append(u'</table>')
                files = cd['files']
                if files:
                    text.append(u'<table cellspacing="10"><tr><th align="left">Files</th><th>URL</th></tr>')
                    for file in files:
                        text.append(u'<tr><td>%s:</td><td>%s</td></tr>' % (file['name'], file['url']))
                    text.append(u'</table>')
        text.append(u'<br>')
        logs = build.getLogs()
        text.append(u'<h4>Unsuccessful Build Steps</h4>')
        for log in reversed(logs):
            if log.getName() != 'stdio':
                continue
            status, dummy = log.getStep().getResults()
            if  status == 0:
                continue
            url = u'%s/steps/%s/logs/%s' % (master_status.getURLForThing(build),
                                       log.getStep().getName(),
                                       log.getName())
            name = "%s.%s" % (log.getStep().getName(), log.getName())
            status, dummy = log.getStep().getResults()
            content = log.getText().splitlines() # Note: can be VERY LARGE
            url = u'%s/steps/%s/logs/%s' % (master_status.getURLForThing(build),
                                           log.getStep().getName(),
                                           log.getName())
            text.append(u'<h4>Last %d lines of: <a href="%s">%s</a>, Status: %s</h4>' % (limit_lines, url, name, status))
            unilist = list()
            for line in content[len(content)-limit_lines:]:
                unilist.append(cgi.escape(unicode(line,'utf-8')))
            text.append(u'<pre>'.join([uniline for uniline in unilist]))
            text.append(u'</pre>')
    text.append(u'<br><br>')
    text.append(u'<b>-The Buildbot</b>')
    return text

def html_Check_DatasetsFormatter(mode, name, build, results, master_status):

    # Following generates blamelist for dynamic email list
    short_name = BD[name]['SHORT_BUILD_NAME']
    #/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
    # TBD: filename = "%s/builds/%s/work/BlameNotification.list" %( BUILDBOT_HOME, short_name )
    filename = "%s/builds/SCheck/work/BlameNotification.list" %( BUILDBOT_HOME)
    #/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
    if  os.path.isfile(filename):
        receivers = open(filename).read().splitlines()
    else:
        receivers = ["raa <robyn@lsst.org"]
    print "email RECEIVERS:"
    print receivers

    # Build complete email message and load into 'text'
    text = update_mailBody(mode, name, build, results, master_status, receivers)

#/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
#  Following not needed since Check Datasets and Doxygen only report  to 
#  $BUCK_STOPS_HERE; however, this fcn is useful to test new tweeks to mailers
#/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
#    # Following sends out mail to dynamic email list
#    if  os.path.isfile(filename):
#        sender = 'Buildbot Nanny <robyn@LSST.org>'
#        message = """\
#From: %s
#To: %s
#MIME-Version: 1.0
#Content-type: text/html
#Subject: [BUILDBOT] %s ... failure you should review.
#
#<br>%s
#""" % ( sender, ", ".join(receivers), name, u"\n".join(text) )
#        try:
#            smtpObj = smtplib.SMTP('localhost')
#            smtpObj.sendmail(sender, receivers, message)         
#            print "Successfully sent email"
#        except SMTPException:
#            print "Error: unable to send email"
#/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/

    # Following sends out the official mailNotifier mail to static email list
    return {
        'body': u"\n".join(text),
        'type': 'html' 
    }


# Build the Body of the email message used by most of the formatters
def build_mailBody(mode, name, build, results, master_status, dm_blame_list):
    result = Results[results]
    buildProperties = build.getProperties()
    buildNumber = buildProperties['buildnumber']
    buildSlaveHostName = build.getSlavename()
    shortSlaveHostName, dummy = buildSlaveHostName.split('.',1)
 
    buildHome = BD[name]['LSST_HOME']
    buildSandbox = "%s/%s/%s/sandbox" %(SLAVE_HOME_DIR, shortSlaveHostName, BD[name]['SHORT_BUILD_NAME'])
    workDir = "%s/%s/work" %(SLAVE_BUILDS_DIR, BD[name]['SHORT_BUILD_NAME'])
    dummy, language = name.rsplit('_',1)
    if language == "Gcc": buildLanguage = "gcc"
    elif language == "Clg": buildLanguage = "clang"
    else: buildLanguage = ""
    if BD[name].has_key('LSST_DEVEL'):
        eupsPath = "%s:%s" %(buildSandbox, buildHome)
    else:
        eupsPath = buildHome


    limit_lines = 20
    address_list = ", ".join(dm_blame_list).translate(maketrans("<>","[]"))
    text = list()
    text.append(u'<h4>Build status: %s</h4>' % result.upper())
    text.append(u'<table cellspacing="10"><tr>')
    text.append(u"<td>Build Name:</td><td><b>%s</b></td></tr>" % name)
    text.append(u"<td>Short Build Name:</td><td><b>%s</b></td></tr>" % BD[name]['SHORT_BUILD_NAME'])
    text.append(u"<td>Build Number:</td><td><b>%s</b></td></tr>" % buildNumber)
    text.append(u"<td>Buildslave:</td><td><b>%s</b></td></tr>" % buildSlaveHostName)
    text.append(u"<td>Build Home:</td><td><b>%s</b></td></tr>" % buildHome)
    text.append(u"<td>Build Sandbox:</td><td><b>%s</b></td></tr>" % buildSandbox)
    text.append(u"<td>Short Slave Name:</td><td><b>%s</b></td></tr>" % shortSlaveHostName)

    if buildLanguage != "":
        text.append(u"<td>Compilation Language: </td><td><b>%s</b></td></tr>" % buildLanguage)
    text.append(u"<td>Eups Path:</td><td><b>%s</b></td></tr>" % eupsPath)
    text.append(u"<td>Work Directory:</td><td><b>%s</b></td></tr>" % workDir)
    if master_status.getURLForThing(build):
        text.append(u'<tr><td>Complete logs for all build steps:</td><td><a href="%s">%s</a></td></tr>'
                    % (master_status.getURLForThing(build),
                       master_status.getURLForThing(build))
                    )
        text.append(u'<tr><td>Build Reason:</td><td>%s</td></tr>' % build.getReason())
        source = u""
        ss = build.getSourceStamp()
        if ss.branch:
            source += u"[branch %s] " % ss.branch
        if ss.revision:
            source +=  ss.revision
        else:
            source += u"HEAD"
        if ss.patch:
            source += u" (plus patch)"
        if ss.patch_info: # add patch comment
            source += u" (%s)" % ss.patch_info[1]
        text.append(u"<tr><td>Build Source Stamp:</td><td><b>%s</b></td></tr>" % source)
        text.append(u"<tr><td>Blamelist:</td><td>%s</td></tr>" % address_list)
        text.append(u'</table>')
        if ss.changes:
            text.append(u'<h4>Changes Initiating Build:</h4>')
            for c in ss.changes:
                cd = c.asDict()
                when = datetime.datetime.fromtimestamp(cd['when'] ).ctime()
                text.append(u'<table cellspacing="10">')
                text.append(u'<tr><td>Repository:</td><td>%s</td></tr>' % cd['repository'] )
                text.append(u'<tr><td>Project:</td><td>%s</td></tr>' % cd['project'] )
                text.append(u'<tr><td>Time:</td><td>%s</td></tr>' % when)
                text.append(u'<tr><td>Changed by:</td><td>%s</td></tr>' % cd['who'] )
                text.append(u'<tr><td>Comments:</td><td>%s</td></tr>' % cd['comments'] )
                text.append(u'</table>')
                files = cd['files']
                if files:
                    text.append(u'<table cellspacing="10"><tr><th align="left">Files</th><th>URL</th></tr>')
                    for file in files:
                        text.append(u'<tr><td>%s:</td><td>%s</td></tr>' % (file['name'], file['url']))
                    text.append(u'</table>')
        text.append(u'<h4>Debugging <package> using buildbot environment:</h4>') 
        text.append(u'Go to your local copy of <package>, run the commands:' )
        text.append(u'   % export EUPS_PATH=%s') % (eups_path)
        text.append(u'   % setup -t %s/work/setup/build%s/setup_<package>.lst -r .') % (workDir, shortNumber )
        text.append(u'and debug there.')

        logs = build.getLogs()
        text.append(u'<h4>Failed Build Steps</h4>')
        # for log in reversed(logs): # Don't reverse the logs.
        for log in logs:
            if log.getName() != 'stdio':
                continue
            status, dummy = log.getStep().getResults()
            # status=0: SUCCESS status=1:WARNINGS  status=2:FAILURE
            if status != 2:
                continue
            url = u'%s/steps/%s/logs/%s' % (master_status.getURLForThing(build),
                                       log.getStep().getName(),
                                       log.getName())
            name = "%s.%s" % (log.getStep().getName(), log.getName())
            status, dummy = log.getStep().getResults()
            content = log.getText().splitlines() # Note: can be VERY LARGE
            url = u'%s/steps/%s/logs/%s' % (master_status.getURLForThing(build),
                                           log.getStep().getName(),
                                           log.getName())
            text.append(u'<h4>Last %d lines of: <a href="%s">%s</a>, Status: %s</h4>' % (limit_lines, url, name, status))
            unilist = list()
            for line in content[len(content)-limit_lines:]:
                unilist.append(cgi.escape(unicode(line,'utf-8')))
            text.append(u'<pre>'.join([uniline for uniline in unilist]))
            text.append(u'</pre>')

        text.append(u'<h4>Build Steps with WARNINGS</h4>')
        for log in logs:
            if log.getName() != 'stdio':
                continue
            status, dummy = log.getStep().getResults()
            if  status != 1:
                continue
            url = u'%s/steps/%s/logs/%s' % (master_status.getURLForThing(build),
                                       log.getStep().getName(),
                                       log.getName())
            name = "%s.%s" % (log.getStep().getName(), log.getName())
            status, dummy = log.getStep().getResults()
            content = log.getText().splitlines() # Note: can be VERY LARGE
            url = u'%s/steps/%s/logs/%s' % (master_status.getURLForThing(build),
                                           log.getStep().getName(),
                                           log.getName())
            text.append(u'<h4>Last %d lines of: <a href="%s">%s</a>, Status: %s</h4>' % (limit_lines, url, name, status))
            unilist = list()
            for line in content[len(content)-limit_lines:]:
                unilist.append(cgi.escape(unicode(line,'utf-8')))
            text.append(u'<pre>'.join([uniline for uniline in unilist]))
            text.append(u'</pre>')
    text.append(u'<br><br>')
    text.append(u'<b>-The Buildbot</b>')
    return text

# Notify mail_list on Build failure
def html_MasterFormatter(mode, name, build, results, master_status):
    """Provide a customized message to Buildbot's MailNotifier.

    The last 80 lines of the log are provided as well as the changes
    relevant to the build.  Message content is formatted as html.
    """
    # Following generates blamelist for dynamic email list
    short_name = BD[name]['SHORT_BUILD_NAME']
    #/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
    # TBD: filename = "%s/builds/%s/work/BlameNotification.list" %( BUILDBOT_HOME, short_name )
    filename = "%s/builds/SCheck/work/BlameNotification.list" %(BUILDBOT_HOME)
    #/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
    if  os.path.isfile(filename):
        receivers = open(filename).read().splitlines()
    else:
        receivers = ["raa <robyn@lsst.org"]

    # Build complete email message and load into 'text'
    text = build_mailBody(mode, name, build, results, master_status, receivers)

    # Following sends out mail to dynamic email list
    if  os.path.isfile(filename):
        sender = 'Buildbot Nanny <robyn@LSST.org>'
        message = """\
From: %s
To: %s
MIME-Version: 1.0
Content-type: text/html
Subject: %s ... failure you should review.

<br>%s
""" % ( sender, ", ".join(receivers), name, u"\n".join(text) )
        try:
            smtpObj = smtplib.SMTP('localhost')
            smtpObj.sendmail(sender, receivers, message)
            print "Successfully sent email"
        except SMTPException:
            print "Error: unable to send email"

    # Following sends out the official mailNotifier mail to static email list
    return {
       'body': u"\n".join(text),
       'type': 'html'
        }

# Notify mail_list on Misc Builders failing or warning
#              B U I L D   C O N D I T I O N A L   B L O C K
if BB_DEVEL:
    c['status'].append(mail.MailNotifier(fromaddr=BUILDBOT_EMAIL,
        mode="warnings",    
        builders=["Check_Datasets"],
        subject="%(builder)s ... failure",
        extraRecipients=[BUILDBOT_EMAIL],
        sendToInterestedUsers=False,
        messageFormatter=html_Check_DatasetsFormatter))
else:
    c['status'].append(mail.MailNotifier(fromaddr=BUILDBOT_EMAIL,
        mode="warnings",    
        builders=["Check_Datasets",  "Doxygen_Build"],
        subject="%(builder)s ... failure",
        extraRecipients=[BUILDBOT_EMAIL],
        sendToInterestedUsers=False,
        messageFormatter=html_Check_DatasetsFormatter))

# Notify mail_list on Master or Branch build failures
c['status'].append(mail.MailNotifier(fromaddr=BUILDBOT_EMAIL,
    mode="failing",    
    categories=["master", "branch"],
    subject="%(builder)s ... master or branch build failure",
    extraRecipients=[BUILDBOT_EMAIL],
    sendToInterestedUsers=False,
    messageFormatter=html_MasterFormatter))

# Notify mail_list on Tag build failures
c['status'].append(mail.MailNotifier(fromaddr=BUILDBOT_EMAIL,
    mode="failing",    
    categories=["tag"],
    subject="%(builder)s ... tag build failure",
    extraRecipients=[BUILDBOT_EMAIL],
    sendToInterestedUsers=False,
    messageFormatter=html_MasterFormatter))


# -- Authorization to perform various user initiated actions
#    'forceBuild' and 'pingBuilder' actions both supply a BuilderStatus object. 
#    'stopBuild' action supplies a BuildStatus object. 
#    'cancelPendingBuild' action supplies a BuildRequest. 
#    The remainder do not supply any extra arguments.
# /\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
#       N O T E :   authorization 
#
#       Don't allow users to start the nightly full Build slaves
#       Don't allow users to stop the drpRun slaves since stack not autonomous
# /\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/

def canForceBuild(username, builder_status):
#/usr/lib/python2.6/site-packages/buildbot-0.8.5-py2.6.egg/buildbot/status/builder.py
    if builder_status.getName() in ( "User_Tag_Build_Rh6_Gcc", 
       "User_Branch_Build_Rh6_Gcc", "User_Branch_Build_Rh6_Clg" ) :
        return True
    if username in ( 'srp', 'raa' ) :
        return True
    else:
        return False
     
#/usr/lib/python2.6/site-packages/buildbot-0.8.5-py2.6.egg/buildbot/status/buildstatus.py
def canStopBuild(username, build_status):
    builderName = build_status.getBuilder().getName()
    if builderName in ( "User_Tag_Build_Rh6_Gcc", 
        "User_Branch_Build_Rh6_Gcc", "User_Branch_Build_Rh6_Clg" ) :
        return True
    if username in ( 'srp', 'raa' ) :
        return True
    else:
        return False

#/usr/lib/python2.6/site-packages/buildbot-0.8.5-py2.6.egg/buildbot/status/buildrequest.py
def canCancelPendingBuild(username,build_request):
    if build_request.original_builder.name in ( "User_Tag_Build_Rh6_Gcc", 
        "User_Branch_Build_Rh6_Gcc", "User_Branch_Build_Rh6_Clg" ) :
        return True
    if username in ( 'srp', 'raa' ) :
        return True
    else:
        return False


authz_cfg = authz.Authz(auth=(HTPasswdAuth(HTPASSWD)),
        gracefulShutdown=False, 
        forceBuild=canForceBuild, 
        forceAllBuilds=False, 
        pingBuilder=False, 
        stopBuild=canStopBuild, 
        stopAllBuilds=False, 
        cancelPendingBuild=canCancelPendingBuild)

c['status'].append(html.WebStatus(http_port=BB_PORT, authz=authz_cfg))

######

from buildbot.config import BuilderConfig


####### PROJECT IDENTITY

# the 'title' string will appear at the top of this buildbot
# installation's html.WebStatus home page (linked to the
# 'titleURL') and is embedded in the title of the waterfall HTML page.

c['title'] = "LSST Data Management"
c['titleURL'] = "http://dev.lsstcorp.org/build"

# the 'buildbotURL' string should point to the location where the buildbot's
# internal web server (usually the html.WebStatus page) is visible. This
# typically uses the port number set in the Waterfall 'status' entry, but
# with an externally-visible host name which the buildbot cannot figure out
# without some help.

c['buildbotURL'] = STDIO_BUILDLOG_URL

####### DB URL

# This specifies what database buildbot uses to store change and scheduler
# state.  You can leave this at its default for all but the largest
# installations.
c['db_url'] = "sqlite:///state.sqlite"

