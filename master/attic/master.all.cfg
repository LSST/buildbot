# -*- python -*-
# ex: set syntax=python:

c = BuildmasterConfig = {}

from buildbot.buildslave import BuildSlave
# max_builds 1 because some tasks share an LSST stack, which doesn't handle simultaneous modifications well
c['slaves'] = [BuildSlave("trachea", "accio_build", notify_on_missing="bbb@uiuc.edu", missing_timeout=300, max_builds=1),
               BuildSlave("tractor", "accio_build", notify_on_missing="bbb@uiuc.edu", missing_timeout=300, max_builds=1),
               BuildSlave("traction", "accio_build", notify_on_missing="bbb@uiuc.edu", missing_timeout=300, max_builds=1),
               BuildSlave("fuse", "accio_build", notify_on_missing="bbb@uiuc.edu", missing_timeout=300, max_builds=1),
               BuildSlave("wire", "accio_build", notify_on_missing="bbb@uiuc.edu", missing_timeout=300, max_builds=1),
               BuildSlave("tracula", "accio_build", notify_on_missing="bbb@uiuc.edu", missing_timeout=300, max_builds=1),
               ]
c['slavePortnum'] = 9989

from buildbot.changes.svnpoller import SVNPoller
c['change_source'] = []
#c['change_source'].append(SVNPoller("svn+ssh://svn.lsstcorp.org/DMS/", pollinterval=60))

from buildbot.scheduler import Scheduler
from buildbot.scheduler import Periodic
from buildbot.scheduler import Nightly
from buildbot.scheduler import Dependent
c['schedulers'] = []
#c['schedulers'].append(Scheduler(name="trigger", branch=None, treeStableTimer=2*60, builderNames=["test_repos_compile"]))
#c['schedulers'].append(Periodic(name="every two hours", periodicBuildTimer=7200, builderNames=["piecemeal", "monolithic"]))

# 12:30 every night: install current release from scratch
nightly_release = Nightly(name="Nightly release install", hour=22, minute=00, builderNames=["Release Pipeline 64", "Release Pipeline 32"])
c['schedulers'].append(nightly_release)
# 3:00 every night: build trunk against minimum requirements
nightly_trunk = Nightly(name="Nightly trunk build", hour=3, minute=30, builderNames=["Nightly Trunk 64", "Nightly Trunk 64 Alt", "Nightly Trunk 32", "Nightly Trunk vs Current", "Nightly Trunk vs Current Alt"])
c['schedulers'].append(nightly_trunk)

from buildbot.process import factory
from buildbot.steps.source import SVN
from buildbot.steps.shell import ShellCommand
#c['builders'] = []

log_args = "-log_dest tracula:/var/www/html/buildlogs -log_url http://dev.lsstcorp.org/buildlogs"

class LogFileShellCommand(ShellCommand):
    log_files = []
    log_files.append("config.log")
    log_files.append("build.log")

    def __init__(self, **kwargs):
        # And upcall to let the base class do its work
        ShellCommand.__init__(self, **kwargs)

    def createSummary(self, log):
        for line in log.getText().split("\n"):
            for log_file in self.log_files:
                # line format is "    log file build.log saved to http://dev.lsstcorp.org/...."
                if (line.startswith("log file ") and line.find(" saved to ") >= 0):
                    split = line.split(" saved to ", 1)
                    self.addURL(split[0].split("log file ")[1], split[1])

slave_home_dir = "/home/buildbot"
slave_scripts_dir = slave_home_dir + "/svn/lsst/buildbot/scripts"
slave_script_prefix = "time " + slave_scripts_dir

f_release_pipeline = factory.BuildFactory()
f_release_pipeline.addStep(ShellCommand(workdir="work",  name="erase", description="erase old working dir", command="rm -rf *"))
f_release_pipeline.addStep(ShellCommand(workdir="work", name="newinstall", description="install LSST tools", command=slave_script_prefix + "/run_newinstall.sh", timeout=2400))
# install LSSTPipe and check that pex_harness and mops are both installed
#f_release_pipeline.addStep(LogFileShellCommand(workdir="work", name="LSSTPipe", description="install LSSTPipe", command=slave_script_prefix + "/release_package.sh LSSTPipe pex_harness mops", timeout=14400))
# for now, don't check dependencies, since they change from time to time
f_release_pipeline.addStep(LogFileShellCommand(workdir="work", name="LSSTPipe", description="install LSSTPipe", command=slave_script_prefix + "/release_package.sh LSSTPipe", timeout=18000))
f_release_pipeline.addStep(LogFileShellCommand(workdir="work", name="Log Files", description="capture log files", command=slave_script_prefix + "/capture_logs.sh tracula:/var/www/html/buildlogs http://dev.lsstcorp.org/buildlogs build.log config.log", timeout=600))
b_release_pipeline_64 = { 'name': "Release Pipeline 64", 'slavename': "trachea", 'builddir': "lsst_install_trachea", 'factory': f_release_pipeline }
#c['builders'].append(b_release_pipeline_64)
b_release_pipeline_32 = { 'name': "Release Pipeline 32", 'slavename': "tractor", 'builddir': "lsst_install_tractor", 'factory': f_release_pipeline }
#c['builders'].append(b_release_pipeline_32)

# same thing, but without starting from scratch -- that is, don't erase old working dir
f_release_no_erase = factory.BuildFactory()
f_release_no_erase.addStep(LogFileShellCommand(workdir="work", name="LSSTPipe", description="install LSSTPipe", command=slave_script_prefix + "/release_package.sh LSSTPipe", timeout=14400))
f_release_no_erase.addStep(LogFileShellCommand(workdir="work", name="Log Files", description="capture log files", command=slave_script_prefix + "/capture_logs.sh tracula:/var/www/html/buildlogs http://dev.lsstcorp.org/buildlogs build.log config.log", timeout=600))
b_release_no_erase_64 = { 'name': "Release 64 incremental", 'slavename': "trachea", 'builddir': "lsst_install_trachea_2", 'factory': f_release_no_erase }
#c['builders'].append(b_release_no_erase_64)
b_release_no_erase_32 = { 'name': "Release 32 incremental", 'slavename': "tractor", 'builddir': "lsst_install_tractor_2", 'factory': f_release_no_erase }
#c['builders'].append(b_release_no_erase_32)

import urllib2
#f = urllib2.urlopen("http://lsstdev.ncsa.uiuc.edu/dmspkgs/manifests/LSSTPipe-3.1.manifest")
f = urllib2.urlopen("http://dev.lsstcorp.org/dmspkgs/active.list")
manifest_lines = f.readlines()
pkgs = []
try:
    for line in manifest_lines:
        line = line.strip()
        if line.startswith('EUPS') or line.startswith('#') or line.find("external") >= 0:
            continue
        try:
            parts = line.split()
            if parts[0] == "scons":
                continue
            # 0 name, 1 flavor, 2 version, 3 tablefile, 4 install dir, 5 install id
            # pkgs.append([parts[0], parts[2], parts[3]])
            pkgs.append([parts[0]]) # active.list is not a manifest file, so don't parse it as one
        except IndexError:
            pass
finally:
    f.close()

trunk_uniq = []
f_trunk_each = factory.BuildFactory()
f_trunk_each_current = factory.BuildFactory()
step_update_pipe = LogFileShellCommand(workdir="work", name="update stack", description="update stack", timeout=12000, command=slave_script_prefix + "/release_package.sh -lsstdir /lsst/stacks/default -C LSSTPipe")
f_trunk_each.addStep(step_update_pipe)
f_trunk_each_current.addStep(step_update_pipe)
all_packages = ""
for pkg_ver in pkgs:
    name = pkg_ver[0]
    if name in trunk_uniq: #skip duplicates
        continue
    trunk_uniq.append(name)
    all_packages = all_packages + " " + name
    # add a step for each package
    trunk_cmd = slave_script_prefix + "/trunk_install.sh -force " + log_args + " " + name + " trunk"
    trunk_step = LogFileShellCommand(workdir="work", name=name, description=name + " trunk", timeout=2400, command=trunk_cmd)
    f_trunk_each.addStep(trunk_step)
    # ditto for build against current
    trunk_cmd_current = slave_script_prefix + "/trunk_install.sh -force -against_current " + log_args + " " + name + " trunk"
    trunk_step_current = LogFileShellCommand(workdir="work", name=name, description=name + " trunk", timeout=2400, command=trunk_cmd_current)
    f_trunk_each_current.addStep(trunk_step_current)
    # monitor each package
    package_branch = name.replace("_", "/")
    c['change_source'].append(SVNPoller("svn+ssh://svn.lsstcorp.org/DMS/" + package_branch + "/trunk", pollinterval=300))

#f_trunk_each.addStep(LogFileShellCommand(workdir="work/svn", name="Log Files", description="capture log files", command=slave_script_prefix + "/capture_logs.sh tracula:/var/www/html/buildlogs http://dev.lsstcorp.org/buildlogs config.log", timeout=14400))
# build trunk against current
b_trunk_each_current = { 'name': "Nightly Trunk vs Current", 'slavename': "traction", 'builddir': "trunk_current", 'factory': f_trunk_each_current }
b_trunk_each_current_alt = { 'name': "Nightly Trunk vs Current Alt", 'slavename': "wire", 'builddir': "trunk_current_alt", 'factory': f_trunk_each_current }
# build trunk against minimal dependencies
b_trunk_each_64 = { 'name': "Nightly Trunk 64", 'slavename': "trachea", 'builddir': "trunk_install_trachea", 'factory': f_trunk_each }
b_trunk_each_64_alt = { 'name': "Nightly Trunk 64 Alt", 'slavename': "fuse", 'builddir': "trunk_install_fuse", 'factory': f_trunk_each }
b_trunk_each_32 = { 'name': "Nightly Trunk 32", 'slavename': "tractor", 'builddir': "trunk_install_tractor", 'factory': f_trunk_each }
#c['builders'].append(b_trunk_each_current)
#c['builders'].append(b_trunk_each_64)
#c['builders'].append(b_trunk_each_32)

# trigger an incremental trunk build on checkins
f_triggered_current = factory.BuildFactory()
f_triggered_32 = factory.BuildFactory()
f_triggered_64 = factory.BuildFactory()
f_triggered_current.addStep(step_update_pipe)
f_triggered_32.addStep(step_update_pipe)
f_triggered_64.addStep(step_update_pipe)
triggered_cmd_current = slave_script_prefix + "/triggered_trunk.sh -against_current " + log_args + " -name \"Triggered Trunk vs Current\" " + all_packages
triggered_cmd_32 = slave_script_prefix + "/triggered_trunk.sh " + log_args + " -name \"Triggered Trunk 32\" " + all_packages
triggered_cmd_64 = slave_script_prefix + "/triggered_trunk.sh " + log_args + " -name \"Triggered Trunk 64\" " + all_packages
f_triggered_current.addStep(LogFileShellCommand(workdir="work", name="Incremental Trunk", description="Incremental Trunk Build", timeout=3600, command=triggered_cmd_current))
f_triggered_32.addStep(LogFileShellCommand(workdir="work", name="Incremental Trunk", description="Incremental Trunk Build", timeout=3600, command=triggered_cmd_32))
f_triggered_64.addStep(LogFileShellCommand(workdir="work", name="Incremental Trunk", description="Incremental Trunk Build", timeout=3600, command=triggered_cmd_64))
b_triggered_current = { 'name': "Triggered Trunk vs Current", 'slavename': "traction", 'builddir': "triggered_current", 'factory': f_triggered_current }
b_triggered_current_alt = { 'name': "Triggered Trunk vs Current Alt", 'slavename': "wire", 'builddir': "triggered_current_alt", 'factory': f_triggered_current }
b_triggered_32 = { 'name': "Triggered Trunk 32", 'slavename': "tractor", 'builddir': "triggered_32", 'factory': f_triggered_32 }
b_triggered_64 = { 'name': "Triggered Trunk 64", 'slavename': "trachea", 'builddir': "triggered_64", 'factory': f_triggered_64 }
b_triggered_64_alt = { 'name': "Triggered Trunk 64 Alt", 'slavename': "fuse", 'builddir': "triggered_64_alt", 'factory': f_triggered_64 }
#c['builders'].append(b_triggered_current)
#c['builders'].append(b_triggered_64)
#c['builders'].append(b_triggered_32)
sched_trigger = Scheduler(name="trigger DMS", branch=None, treeStableTimer=11*60, builderNames=["Triggered Trunk 64", "Triggered Trunk 64 Alt", "Triggered Trunk 32", "Triggered Trunk vs Current", "Triggered Trunk vs Current Alt"])
c['schedulers'].append(sched_trigger)
# 3 pm every Sunday: run triggered trunk build after weekly cleanup
#weekly_trigger_reset = Nightly(name="Triggered weekly reset", hour=15, dayOfWeek=7, builderNames=["Triggered Trunk 64", "Triggered Trunk 32"])
#c['schedulers'].append(weekly_trigger_reset)

# create a build for each package, triggered on checkins
#for name in trunk_uniq:
#    package_branch = name.replace("_", "/")
#    #c['change_source'].append(SVNPoller("svn+ssh://svn.lsstcorp.org/DMS/" + package_branch, pollinterval=60))
#    f_triggered = factory.BuildFactory()
#    trunk_cmd = slave_script_prefix + "/trunk_install.sh -force " + log_args + " " + name + " trunk"
#    f_triggered.addStep(LogFileShellCommand(name=name, description="install " + name + " from trunk", timeout=14400, command=trunk_cmd))
#    b_triggered = { 'name': "Triggered " + name, 'slavename': "trachea", 'builddir': "triggered_" + name, 'factory': f_triggered }
#    c['builders'].append(b_triggered)
#    c['schedulers'].append(Scheduler(name="trigger_" + name, branch="DMS/" + package_branch, treeStableTimer=2*60, builderNames=["Triggered " + name]))
    
c['status'] = []

from buildbot.status import html
c['status'].append(html.WebStatus(http_port=8010, allowForce=True))

from buildbot.status import mail
c['status'].append(mail.MailNotifier(fromaddr="bbb@illinois.edu", extraRecipients=["bbb@illinois.edu", "dgehrig@ncsa.uiuc.edu", "rplante@ncsa.uiuc.edu"], mode="problem", sendToInterestedUsers=True))

c['projectName'] = "LSST Build"
c['projectURL'] = "http://dev.lsstcorp.org/build/"
c['buildbotURL'] = "http://dev.lsstcorp.org/build/"

# moved these all down here to control order of builders all in one place
c['builders'] = []
c['builders'].append(b_triggered_64)
c['builders'].append(b_triggered_32)
c['builders'].append(b_triggered_current)
c['builders'].append(b_triggered_64_alt)
c['builders'].append(b_triggered_current_alt)
c['builders'].append(b_trunk_each_64)
c['builders'].append(b_trunk_each_32)
c['builders'].append(b_trunk_each_current)
c['builders'].append(b_trunk_each_64_alt)
c['builders'].append(b_trunk_each_current_alt)
c['builders'].append(b_release_pipeline_64)
c['builders'].append(b_release_pipeline_32)
c['builders'].append(b_release_no_erase_64)
c['builders'].append(b_release_no_erase_32)
