# -*- python -*-
# ex: set syntax=python:

#=============================================================================
#  Following are Shared Globals
#=============================================================================
# NOTE: the VM's have native gcc 4.5 but LSST uses gcc 4.4 for buildbot & lsst-eups; 
#       must pass from master PATH/LD_LIBRARY_PATH for all build types (critically Release builds)
#       If LSST_HOME and/or LSST_DEVEL varies between two co-hosted builds, see Release build setup for how-to
env={'PATH':"/lsst/DC3/stacks/gcc443/opt/gcc44/4.4.3/bin:/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/sbin:/home/buildbot/scripts:/home/buildbot/bin",'LD_LIBRARY_PATH':"/lsst/DC3/stacks/gcc443/opt/gcc44/4.4.3/lib64"}
LSST_HOME = "/lsst/DC3/stacks/gcc443"
LSST_DEVEL = "/home/buildbot/buildbotSandbox"

slave_home_dir = "/home/buildbot"
slave_scripts_dir = slave_home_dir + "/scripts"
slave_script_prefix = "time " + slave_scripts_dir

#=============================================================================
#  Following sets up the Buildbot Master -- on tracula
#  -- however completion of this setup occurs after all build definitions have been created
#=============================================================================
c = BuildmasterConfig = {}

# slaves
from buildbot.buildslave import BuildSlave
    # max_builds=1: some tasks share LSST stack which can't handle simultaneous modifications 
    # -- 64 bit buildbot Slaves --
c['slaves'] = [BuildSlave("willy", "accio_build", notify_on_missing="rallsman@lsst.org", 
    missing_timeout=300, max_builds=1),
    BuildSlave("traction", "accio_build", notify_on_missing="rallsman@lsst.org", 
    missing_timeout=300, max_builds=1),
    BuildSlave("fbot", "accio_build", notify_on_missing="rallsman@lsst.org", 
    missing_timeout=300, max_builds=1),
    BuildSlave("lsst6", "accio_build", notify_on_missing="rallsman@lsst.org", 
    missing_timeout=300, max_builds=1),
    # -- 32 bit buildbot Slaves --
    BuildSlave("tractor", "accio_build", notify_on_missing="rallsman@lsst.org", 
    missing_timeout=300, max_builds=1),
    ]
c['slavePortnum'] = 9989

# -- sources
from buildbot.changes.svnpoller import SVNPoller
c['change_source'] = []
c['change_source'].append(SVNPoller("svn://svn.lsstcorp.org/DMS/", pollinterval=60))

# -- schedulers
from buildbot.scheduler import Scheduler
from buildbot.scheduler import Periodic
from buildbot.scheduler import Nightly
from buildbot.scheduler import Dependent
c['schedulers'] = []
# scheduling style: triggered, periodic, scheduled
nightly_release = Nightly( name="Nightly release install", hour=22, minute=00, 
    builderNames=["Release_Pipeline"])
nightly_incremental_release = Nightly( name="Nightly incremental release install", hour=3, minute=10, 
    builderNames=["Release_Incremental"] )
nightly_TvT = Nightly(name="Nightly Full_Trunk_vs_Trunk", hour=0, minute=05,
    builderNames=["Full_Trunk_vs_Trunk"] ) 
nightly_TvTNT = Nightly(name="Nightly Full_Trunk_vs_Trunk_NoTest", hour=0, minute=05 ,
    builderNames=["Full_Trunk_vs_Trunk_NoTest"] )
nightly_datarel_TvTNT = Nightly(name="Nightly Datarel_Trunk_vs_Trunk", 
    month=12, dayOfMonth=24, hour=12, minute=0 , builderNames=["Datarel_Trunk_vs_Trunk"] )
# nightly_trunk = Nightly(name="Nightly trunk build", hour=2, minute=30, 
#    builderNames=["Full Trunk vs Current", "Full Trunk vs Minimal"] )
# sched_trigger = Scheduler(name="trigger DMS", branch=None, 
#    treeStableTimer=11*60, builderNames=["Trunk vs Minimal", "Trunk vs Current"])
# sched_trigger = Scheduler(name="trigger DMS", branch=None, 
#    treeStableTimer=11*60, builderNames=["Trunk vs Current"] )
#                   nightly_TvTNT,
#                   sched_trigger,
c['schedulers'] = [nightly_release, 
                   nightly_incremental_release,
                   nightly_TvT, 
                   nightly_datarel_TvTNT] 

# -- logs
from buildbot.process import factory
from buildbot.steps.source import SVN
from buildbot.steps.shell import ShellCommand, WithProperties
log_args = "-log_dest tracula:/var/www/html/buildlogs -log_url http://dev.lsstcorp.org/buildlogs"

class LogFileShellCommand(ShellCommand):
    log_files = []
    log_files.append("config.log")
    log_files.append("build.log")

    def __init__(self, **kwargs):
        # And upcall to let the base class do its work
        ShellCommand.__init__(self, **kwargs)

    def createSummary(self, log):
        for line in log.getText().split("\n"):
            for log_file in self.log_files:
                # line format is "    log file build.log saved to http://dev.lsstcorp.org/...."
                if (line.startswith("log file ") and line.find(" saved to ") >= 0):
                    split = line.split(" saved to ", 1)
                    self.addURL(split[0].split("log file ")[1], split[1])

#=============================================================================
#  Following are the Tagged Release-based Builds
#=============================================================================
# 			 Release Pipeline
# Schedule: cleared environment, from-scratch build using LSSTPipe 
#------------------------------------------------------------------------------
# Since Release and IncRelease are co-hosted, need separate LSST_HOME ... ensure you update the NEW env*
envR = {'LSST_HOME':"/home/buildbot/slave/Release/work"}
envR.update(env)
f_release = factory.BuildFactory()
f_release.addStep(ShellCommand(workdir="work", name="erase", description="erase old working dir", 
    command='rm -rf *; echo "...." $? "...."'))
f_release.addStep(ShellCommand(workdir="work", name="newinstall", description="install LSST tools", 
    env=envR, timeout=3600, command=slave_script_prefix + "/run_newinstall.sh"))
f_release.addStep(LogFileShellCommand(workdir="work", name="LSSTPipe", description="install LSSTPipe",
    env=envR, timeout=18000, command=slave_script_prefix + "/release_package.sh LSSTPipe"))
# This logfile command doesn't save log files of the package build which caused failure. 8 Sep 2011
#    It's doubtful that approach used for Trunk builds works when failure embedded in 'lsstpkg LSSTPipe'
#f_release.addStep(LogFileShellCommand(workdir="work", name="Log Files", description="capture log files",
#    timeout=600, command=slave_script_prefix + "/capture_logs.sh tracula:/var/www/html/buildlogs " + 
#    "http://dev.lsstcorp.org/buildlogs build.log config.log"))
f_release.addStep(LogFileShellCommand(workdir="work", name="build doxyDoc", description="build doxygen docs",
    env=envR, timeout=3600, command=[slave_scripts_dir + "/create_xlinkdocs.sh", "current",
    "buildbot@willy.ncsa.illinois.edu:/var/www/html/doxygen", "http://dev.lsstcorp.org/doxygen"]))

b_release_64_willy = { 'name': "Release_Pipeline", 
    'slavename': "willy",
    'builddir': "Release",
    'factory': f_release 
    }
#b_release_32 = { 'name': "Release_Pipeline 32",
#   'slavename': "tractor",
#   'builddir': "Release",
#   'factory': f_release 
#   }

# -------------------------------------------------------------------------
#                "Release incremental"
#        Schedule build but without starting from scratch 
#        -- that is, don't erase old working dir
# -------------------------------------------------------------------------
envRI = {'LSST_HOME':"/home/buildbot/slave/IncRelease/work"}
envRI.update(env)
f_rel_no_erase = factory.BuildFactory()
f_rel_no_erase.addStep(ShellCommand(workdir="work", name="newinstall", description="install LSST tools", 
    env=envRI, timeout=3600, command=slave_script_prefix + "/run_newinstall.sh"))
f_rel_no_erase.addStep(LogFileShellCommand(workdir="work", name="LSSTPipe", description="install LSSTPipe", 
    env=envRI, timeout=14400, command=slave_script_prefix + "/release_package.sh LSSTPipe"))
# This logfile command doesn't save log files of the package build which caused failure. 8 Sep 2011
#    It's doubtful that approach used for Trunk builds works when failure embedded in 'lsstpkg LSSTPipe'
#f_rel_no_erase.addStep(LogFileShellCommand(workdir="work", name="Log Files",description="capture log files",
#    timeout=600, command=slave_script_prefix + "/capture_logs.sh tracula:/var/www/html/buildlogs " + 
#    "http://dev.lsstcorp.org/buildlogs build.log config.log"))

b_rel_no_erase_64_willy = { 'name': "Release_Incremental", 
    'slavename': "willy", 
    'builddir': "IncRelease", 
    'factory': f_rel_no_erase 
    }
#b_rel_no_erase_32 = { 'name': "Release 32 incremental", 
#    'slavename': "tractor", 
#    'builddir': "IncRelease", 
#    'factory': f_rel_no_erase 
#    }

#=============================================================================
#  Following are the Trunk-based Builds
#=============================================================================
# -- Collect module names for all DM modules
import urllib2
f = urllib2.urlopen("http://dev.lsstcorp.org/dmspkgs/active.list")
manifest_lines = f.readlines()
pkgs = []
try:
    for line in manifest_lines:
        line = line.strip()
        if line.startswith('EUPS') or line.startswith('#') or line.find("external") >= 0:
            continue
        try:
            # name, flavor, version, tablefile, installDir, install id
            parts = line.split()
            if parts[0] == "scons":
                continue
            pkgs.append([parts[0]]) 
        except IndexError:
            pass
finally:
    f.close()

# -------------------------------------------------------------------------
#    full trunk builds - either triggered or scheduled 
#    "Full Trunk vs Current"  "Full Trunk vs Minimal"  "Full Trunk vs Trunk" "Datarel Trunk vs Trunk"
# -------------------------------------------------------------------------
# -- all the Trunk builds need to have both LSST_HOME and LSST_DEVEL defined in path.
envT = {'LSST_HOME':LSST_HOME,'LSST_DEVEL':LSST_DEVEL}
envT.update(env)

# -- shared step among builds: "Full Trunk vs Current"  "Full Trunk vs Minimal"
# --                         : "Full Trunk vs Trunk" "Full Trunk vs Trunk NoTest"
# --                         : "Datarel Trunk vs Trunk"
step_update_pipe = LogFileShellCommand(workdir="work", name="update stack", description="update stack",
   env=envT, timeout=12000, command=slave_script_prefix + 
       "/release_package.sh -lsstdir /lsst/DC3/stacks/default -no_doxygen --tag=current LSSTPipe")

## f_trunk_each = factory.BuildFactory()
## f_trunk_each.addStep(step_update_pipe)

## f_TvsC = factory.BuildFactory()
## f_TvsC.addStep(step_update_pipe)

f_TvsT = factory.BuildFactory()
f_TvsT.addStep(step_update_pipe)

f_TvsTNT = factory.BuildFactory()
f_TvsTNT.addStep(step_update_pipe)

trunk_uniq = []
all_packages = ""
for pkg_ver in pkgs:
    name = pkg_ver[0]
    if name in trunk_uniq: #skip duplicates
        continue
    trunk_uniq.append(name)
    all_packages = all_packages + " " + name

    #--------------------------------------------------------------------
    # build trunk pkg against minimal dependencies specified -- add step per package
    #--------------------------------------------------------------------
    ## f_trunk_each.addStep( LogFileShellCommand(workdir="work", name=name, description=name + " trunk",
    ##     env=envT, timeout=3600, command=slave_script_prefix + 
    ##     "/trunk_install.sh -force " + log_args + " " + name + " trunk"))

    #--------------------------------------------------------------------
    # build trunk package against pre-existing Current versions of dependencies -- add step per package
    #--------------------------------------------------------------------
    ## f_TvsC.addStep( LogFileShellCommand(workdir="work", name=name, description=name + " trunk",
    ##     env=envT, timeout=3600, command=slave_script_prefix + "/trunk_install.sh -force 
    ##     -against_current " + log_args + " " + name + " trunk" ))

    #--------------------------------------------------------------------
    # build trunk package against trunk versions of its dependencies -- add step per package
    #--------------------------------------------------------------------
    f_TvsT.addStep( LogFileShellCommand(workdir="work", name=name, description=name + " trunkVtrunk",
        env=envT, timeout=3600, command=["time", slave_scripts_dir + "/trunkVsTrunk.sh",
        "-log_dest", "tracula:/var/www/html/buildlogs", "-log_url", "http://dev.lsstcorp.org/buildlogs",
        "-builder_name", WithProperties("%s", "buildername"),
        "-build_number", WithProperties("%s", "buildnumber") , name , "trunk" ]))

    #--------------------------------------------------------------------
    # build trunk package against trunk --  but do NOT execute Unit Tests -- add step per package
    #--------------------------------------------------------------------
    # ditto for build trunk against trunk - NO TESTS
    f_TvsTNT.addStep( LogFileShellCommand(workdir="work", name=name, description=name + " trunkVtrunk",
        env=envT, timeout=3600, command=["time", slave_scripts_dir + "/trunkVsTrunk.sh",
        "-log_dest", "tracula:/var/www/html/buildlogs", "-log_url", "http://dev.lsstcorp.org/buildlogs",
        "-builder_name", WithProperties("%s", "buildername"), "-build_number", 
        WithProperties("%s", "buildnumber"), "-slave_devel", "-no_tests", name , "trunk" ]))

    #--------------------------------------------------------------------
    # monitor each package for trunk source change trigger  
    # --  ?Is this superfluous since the original change_source watches the ENTIRE DMS tree (all branches)?
    #--------------------------------------------------------------------
    package_branch = name.replace("_", "/")
    c['change_source'].append(SVNPoller("svn://svn.lsstcorp.org/DMS/" + 
        package_branch + "/trunk", pollinterval=300))

#--------------------------------------------------------------------
# build doxygen documentation for trunk Vs trunk but not for other build varients
#--------------------------------------------------------------------
f_TvsT.addStep( LogFileShellCommand(workdir="work", name="build doxyDoc", description="build doxygen docs",
    env=envT, timeout=3600, command=[slave_scripts_dir + "/create_xlinkdocs.sh", "trunk",
    "buildbot@willy.ncsa.illinois.edu:/var/www/html/doxygen", "http://dev.lsstcorp.org/doxygen"]))

# -- build trunk package against Current dependencies
## b_TvsC = { 'name':"Full Trunk vs Current", 'slavename':"traction", 'builddir':"TvsC", 'factory': f_TvsC }

# -- build trunk package against its minimal stated dependencies
## b_TvsM_64 = {'name':"Full Trunk vs Minimal", 'slavename':"willy", 
##    'builddir':"TvsM",'factory':f_trunk_each}
## b_TvsM_32 = { 'name': "Full Trunk vs Minimal 32", 'slavename': "nilly",
##    'builddir': "TvsM", 'factory': f_trunk_each }

# -- build trunk package against trunk dependencies
b_TvsT = { 'name': "Full_Trunk_vs_Trunk", 'slavename': "fbot", 'builddir': "TvT", 'factory': f_TvsT }

# -- build trunk against trunk with NO TESTS
#b_TvsTNT = {'name': "Full_Trunk_vs_Trunk_NoTest", 'slavename': "fbot", 
#    'builddir': "TvTNT", 'factory': f_TvsTNT }


#-----------------------------------------------------------------------------
# -- datarel's trunk-against-trunk  build
#----------------------------------------------------------------------------
f_datarel_TvsT = factory.BuildFactory()
# No 'step_update_pipe_lsst' on user-shared system unless using private LSST_HOME (as on Release/IncRelease)
f_datarel_TvsT.addStep( LogFileShellCommand(workdir="work", name="datarel", description="datarel trunkVtrunk",
    timeout=3600, env=envT,
    command=["time", slave_scripts_dir + "/prTrunkVsTrunk.sh", "-log_dest", "tracula:/var/www/html/buildlogs",
        "-log_url", "http://dev.lsstcorp.org/buildlogs", "-builder_name", WithProperties("%s", "buildername"),
        "-build_number", WithProperties("%s", "buildnumber") , "-production", "datarel" , "trunk" ]))
b_datarel_TvsT = { 'name': "Datarel_Trunk_vs_Trunk", 'slavename': "lsst6", 
    'builddir': "trunkVsTrunk_lsst", 'factory': f_datarel_TvsT }


#=============================================================================
#  Following are the Triggered on Check-in Builds
#=============================================================================
# -- trigger an incremental trunk build on checkins -- that is,  don't erase old working dir
#       "Trunk vs Current"  and  "Trunk vs Minimal" 
# -------------------------------------------------------------------------

#f_triggered_TvsC = factory.BuildFactory()
#f_triggered_TvsC.addStep(step_update_pipe)
#f_triggered_TvsC.addStep(LogFileShellCommand(workdir="work",
#    name="Triggered Incremental Trunk", description="Triggered Incremental Trunk Build", 
#    env=envT, timeout=3600, command=[slave_scripts_dir + "/triggered_trunk.sh", "-against_current",
#    "-log_dest", "tracula:/var/www/html/buildlogs", "-log_url", "http://dev.lsstcorp.org/buildlogs",
#    "-build_number", WithProperties("%s", "buildnumber") , "-name", "\"Trunk vs Current\"", all_packages] ))
#b_triggered_TvsC_64 = { 'name': "Triggered Trunk vs Current", 'slavename': "willy",
#    'builddir': "triggered_TvsC", 'factory': f_triggered_TvsC }

#f_triggered_TvsM_32 = factory.BuildFactory()
#f_triggered_TvsM_32.addStep(step_update_pipe)
#f_triggered_TvsM_32.addStep(LogFileShellCommand(workdir="work", name="Incremental Trunk",
#    description="Incremental Trunk Build", env=envT, timeout=3600,
#    command=slave_script_prefix + "/triggered_trunk.sh " + log_args + " -name \"Trunk 32\" " +
#    all_packages ))
#b_triggered_TvsM_32 = { 'name': "Trunk vs Minimal 32", 'slavename': "tractor",
#    'builddir': "triggered_TvsM", 'factory': f_triggered_TvsM_32 }

#f_triggered_64 = factory.BuildFactory()
#f_triggered_64.addStep(step_update_pipe)
#f_triggered_64.addStep(LogFileShellCommand(workdir="work", name="Incremental Trunk",
#    description="Incremental Trunk Build", timeout=3600, 
#    command=slave_script_prefix + "/triggered_trunk.sh -email_notify robyn@LSST.org " +
#    log_args + " -name \"Trunk vs Minimal\" " + all_packages) )
#b_triggered_TvsM_64 = { 'name': "Trunk vs Minimal",
#    'slavename': "willy", 'builddir': "triggered_TvsM", 'factory': f_triggered_64 }


#=============================================================================
#  Final Setup for Buildbot Master
#=============================================================================
# -- status
from buildbot.status import html
c['status'] = []
c['status'].append(html.WebStatus(http_port=8010, allowForce=True))

from buildbot.status import mail
c['status'].append(mail.MailNotifier(fromaddr="rallsman@lsst.org",
    extraRecipients=["rallsman@lsst.org"],
    mode="problem",
    sendToInterestedUsers=True))

c['projectName'] = "LSST Build"
c['projectURL'] = "http://dev.lsstcorp.org/build/"
c['buildbotURL'] = "http://dev.lsstcorp.org/build/"

# -- builders
#      moved together to control order of builders 
c['builders'] = []
#c['builders'].append(b_triggered_TvsC_64)       #TBD?? traction: temp willy#
#c['builders'].append(b_triggered_TvsM_64)       #      willy #
#c['builders'].append(b_triggered_TvsM_32)       #TBD?? tractor #
## c['builders'].append(b_TvsC)                  #TBD   traction #
## c['builders'].append(b_TvsM_64)               #TBD   willy #
#c['builders'].append(b_TvsM_32)                 #TBD?? tractor #
c['builders'].append(b_release_64_willy)         #      willy Release #
c['builders'].append(b_rel_no_erase_64_willy)    #      willy IncRelease #
#c['builders'].append(b_release_32)              #TBD?? tractor #
#c['builders'].append(b_rel_no_erase_32)
c['builders'].append(b_TvsT)                     #      fbot Full_Trunk_vs_Trunk #
#c['builders'].append(b_TvsTNT)                  #      fbot #
c['builders'].append(b_datarel_TvsT)             #      lsst6 Daterel_Trunk_vs_Trunk #
