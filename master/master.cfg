# -*- python -*-
# ex: set syntax=python:

from buildbot.status import html
from buildbot.status import mail
from buildbot.status.web import authz


#######
# Shared globals
#######

#BUILDBOT_HOME = "/usr/local/home/buildbot"
BUILDBOT_HOME = "/lsst/home/buildbot/RHEL6"
BUILDBOT_DOXYGEN = BUILDBOT_HOME+"/doxygen"
LSST_HOME = "/lsst/DC3/stacks/gcc445-RH6/14sept2011"

slave_home_dir = BUILDBOT_HOME+"/buildslaves"
slave_builds_dir = BUILDBOT_HOME+"/builds"
slave_scripts_dir = BUILDBOT_HOME+ "/scripts"
slave_script_prefix = "time "+slave_scripts_dir

buildbot_master="srp@ncsa.uiuc.edu"

#
# buildbot slave machines.
#

BUILDBOT_SLAVE1="lsst-build1.ncsa.illinois.edu"

BUILDBOT_SLAVE2="lsst-build2.ncsa.illinois.edu"

BUILDBOT_SLAVE3="lsst-build3.ncsa.illinois.edu"

BUILDBOT_SLAVE4="lsst9.ncsa.illinois.edu"

#
# buildbot slave machines aliases
#
NIGHTLY_RELEASE_PIPELINE_SLAVE=BUILDBOT_SLAVE1

ON_DEMAND_TRUNK_VS_TRUNK_SLAVE=BUILDBOT_SLAVE2
TRUNK_VS_TRUNK_NO_TESTS_SLAVE=BUILDBOT_SLAVE2

DATAREL_TRUNK_VS_TRUNK_SLAVE=BUILDBOT_SLAVE3

WEEKLY_RUN_SLAVE=BUILDBOT_SLAVE4

TRUNK_VS_TRUNK_SLAVE=BUILDBOT_SLAVE4


# This is a sample buildmaster config file. It must be installed as
# 'master.cfg' in your buildmaster's base directory.

# This is the dictionary that the buildmaster pays attention to. We also use
# a shorter alias to save typing.
c = BuildmasterConfig = {}

####### BUILDSLAVES

# The 'slaves' list defines the set of recognized buildslaves. Each element is
# a BuildSlave object, specifying a unique slave name and password.  The same
# slave name and password must be configured on the slave.
from buildbot.buildslave import BuildSlave
c['slaves'] = [
	BuildSlave("lsst-build1.ncsa.illinois.edu", "buildpass1", notify_on_missing=buildbot_master, missing_timeout=300, max_builds=1),
	BuildSlave(ON_DEMAND_TRUNK_VS_TRUNK_SLAVE, "buildpass1", notify_on_missing=buildbot_master, missing_timeout=300, max_builds=1),
	BuildSlave(DATAREL_TRUNK_VS_TRUNK_SLAVE, "buildpass1", notify_on_missing=buildbot_master, missing_timeout=300, max_builds=1),
	BuildSlave(WEEKLY_RUN_SLAVE, "buildpass1", notify_on_missing=buildbot_master, missing_timeout=300, max_builds=1)
]

# 'slavePortnum' defines the TCP port to listen on for connections from slaves.
# This must match the value configured into the buildslaves (with their
# --master option)
c['slavePortnum'] = 9989

####### CHANGESOURCES

# the 'change_source' setting tells the buildmaster how it should find out
# about source code changes.  Here we point to the buildbot clone of pyflakes.

from buildbot.changes.svnpoller import SVNPoller
c['change_source'] = []
c['change_source'].append(SVNPoller( 'svn://svn.lsstcorp.org/DMS/', pollinterval=600)) # every ten minutes

####### SCHEDULERS

# Configure the Schedulers, which decide how to react to incoming changes.  In this
# case, just kick off a 'runtests' build

from buildbot.schedulers.timed import Nightly

nightly_release = Nightly(name="Nightly release install", hour=22, minute=00, builderNames=["Nightly_Release_Pipeline"], branch='master')

c['schedulers'] = []
c['schedulers'].append(nightly_release)

####### logs
from buildbot.process import factory
from buildbot.steps.source import SVN
from buildbot.steps.shell import ShellCommand, WithProperties
log_args = "-log_dest lsst-build:/usr/local/home/buildbot/buildmaster/public_html/buildlogs -log_url http://lsst-build:8010/buildlogs"

class LogFileShellCommand(ShellCommand):
    log_files = []
    log_files.append("config.log")
    log_files.append("build.log")

    def __init__(self, **kwargs):
        # And upcall to let the base class do its work
        ShellCommand.__init__(self, **kwargs)

    def createSummary(self, log):
        for line in log.getText().split("\n"):
            for log_file in self.log_files:
                # line format is "    log file build.log saved to http://dev.lsstcorp.org/...."
                if (line.startswith("log file ") and line.find(" saved to ") >= 0):
                    split = line.split(" saved to ", 1)
                    self.addURL(split[0].split("log file ")[1], split[1])

####### BUILDERS

# The 'builders' list defines the Builders, which tell Buildbot how to perform a build:
# what steps, and which slaves can execute them.  Note that any particular build will
# only take place on one slave.

from buildbot.process import factory
from buildbot.steps.source import SVN
from buildbot.steps.shell import ShellCommand, WithProperties

release_pipeline_factory = factory.BuildFactory()

#####
# Remove old working directory
#####
release_pipeline_factory.addStep(ShellCommand(workdir="work", name="erase", description="erase old working dir", command='rm -rf *; echo "...." $? "...."'))
#####
# execute run_newinstall.sh
#####
sandbox = slave_home_dir+"/"+NIGHTLY_RELEASE_PIPELINE_SLAVE.split('.')[0]+"/sandbox"
release_pipeline_env = {'LSST_HOME': LSST_HOME, 'LSST_DEVEL': sandbox }
release_pipeline_factory.addStep(ShellCommand(workdir="work", name="newinstall", description="install LSST tools", 
    env=release_pipeline_env, timeout=3600, command=slave_script_prefix + "/run_newinstall.sh"))
#####
# execute release_package.sh LSSTPipe
#####
release_pipeline_factory.addStep(LogFileShellCommand(workdir="work", name="LSSTPipe", description="install LSSTPipe",    env=release_pipeline_env, timeout=18000, command=slave_script_prefix + "/release_package.sh LSSTPipe"))

build_release_pipeline = { 
	'name':'Nightly_Release_Pipeline',
	'slavename': NIGHTLY_RELEASE_PIPELINE_SLAVE, 
	'builddir' : slave_builds_dir+'/Release', 
	'factory' : release_pipeline_factory 
	}


#=============================================================================
#  Following are the Trunk-based Builds
#=============================================================================
# -- Collect module names for all DM modules
import urllib2
f = urllib2.urlopen("http://dev.lsstcorp.org/dmspkgs/active.list")
manifest_lines = f.readlines()
pkgs = []
try:
    for line in manifest_lines:
        line = line.strip()
        if line.startswith('EUPS') or line.startswith('#') or line.find("external") >= 0:
            continue
        try:
            # name, flavor, version, tablefile, installDir, install id
            parts = line.split()
            if parts[0] == "scons":
                continue
            pkgs.append([parts[0]]) 
        except IndexError:
            pass
finally:
    f.close()

# -------------------------------------------------------------------------
# on demand builds
# -------------------------------------------------------------------------

# ---------------------------
# this is for on demand builds of a package vs all other trunk packages
# You MUST fill out the "branch to build" with the right package name.
# ---------------------------
sandbox = slave_home_dir+"/"+ON_DEMAND_TRUNK_VS_TRUNK_SLAVE.split('.')[0]+"/sandbox"

on_demand_vs_trunk_build_env = {'LSST_HOME':LSST_HOME,'LSST_DEVEL': sandbox}
on_demand_vs_trunk_factory = factory.BuildFactory()
on_demand_vs_trunk_step_update_pipe = LogFileShellCommand(workdir="work", name="update stack", description="update stack",
   env=on_demand_vs_trunk_build_env, timeout=12000, command=slave_script_prefix + 
       "/release_package.sh -lsstdir "+LSST_HOME+" -lsstdevel "+sandbox+" -no_doxygen --tag=current LSSTPipe")

on_demand_vs_trunk_factory.addStep(on_demand_vs_trunk_step_update_pipe)
on_demand_vs_trunk_factory.addStep( LogFileShellCommand(workdir="work", name="on demand trunkVtrunk",
        env=on_demand_vs_trunk_build_env, timeout=3600, command=["time", slave_scripts_dir+"/trunkVsTrunk.sh",
        "-log_dest", "lsst-build:/usr/local/home/buildbot/buildmaster/public_html/buildlogs", "-log_url", "http://lsst-build:8010/buildlogs",
        "-builder_name", WithProperties("%s", "buildername"),
        "-build_number", WithProperties("%s", "buildnumber") , 
        "-slave_devel", sandbox,
	"-parallel", 2,
	WithProperties("%s","branch"), "trunk" ]))
#	"-no_tests", WithProperties("%s","branch"), "trunk" ]))


on_demand_vs_trunk_builder = { 
	'name': "On_Demand_Vs_Trunk",
	'slavename': ON_DEMAND_TRUNK_VS_TRUNK_SLAVE,
	'builddir': slave_builds_dir+"/ondemand_vs_Trunk",
	'factory': on_demand_vs_trunk_factory 
}


# -------------------------------------------------------------------------
#    full trunk builds - either triggered or scheduled 
#    "Full Trunk vs Current"  "Full Trunk vs Minimal"  "Full Trunk vs Trunk" "Datarel Trunk vs Trunk"
# -------------------------------------------------------------------------
# -- all the Trunk builds need to have both LSST_HOME and LSST_DEVEL defined in path.
TvsT_sandbox = slave_home_dir+"/"+TRUNK_VS_TRUNK_SLAVE.split('.')[0]+"/sandbox"
TvsTNT_sandbox = slave_home_dir+"/"+TRUNK_VS_TRUNK_NO_TESTS_SLAVE.split('.')[0]+"/sandbox"

envT = {'LSST_HOME':LSST_HOME,'LSST_DEVEL': sandbox}

#envT.update(env)

# -- shared step among builds: "Full Trunk vs Current"  "Full Trunk vs Minimal"
# --                         : "Full Trunk vs Trunk" "Full Trunk vs Trunk NoTest"
# --                         : "Datarel Trunk vs Trunk"

f_TvsT = factory.BuildFactory()

step_update_pipe = LogFileShellCommand(workdir="work", name="update stack", description="update stack", env=envT, timeout=12000, command=slave_script_prefix + "/release_package.sh -lsstdir "+LSST_HOME+" -lsstdevel "+TvsT_sandbox+" -no_doxygen --tag=current -astrometry_net_data cfhtlsDeep /lsst/DC3/data/astrometry_net_data/cfhtlsDeep LSSTPipe")
f_TvsT.addStep(step_update_pipe)

f_TvsTNT = factory.BuildFactory()
# update the stack
step_update_pipe = LogFileShellCommand(workdir="work", name="update stack", description="update stack", env=envT, timeout=12000, command=slave_script_prefix + "/release_package.sh -lsstdir "+LSST_HOME+" -lsstdevel "+TvsTNT_sandbox+" -no_doxygen --tag=current LSSTPipe")
f_TvsTNT.addStep(step_update_pipe)

trunk_uniq = []
all_packages = ""
for pkg_ver in pkgs:
    name = pkg_ver[0]
    if name in trunk_uniq: #skip duplicates
        continue
    trunk_uniq.append(name)
    all_packages = all_packages + " " + name

    #--------------------------------------------------------------------
    # build trunk package against trunk versions of its dependencies -- add step per package
    #--------------------------------------------------------------------
    f_TvsT.addStep( LogFileShellCommand(workdir="work", name=name, description=name + " trunkVtrunk",
        env=envT, timeout=3600, command=["time", slave_scripts_dir + "/trunkVsTrunk.sh",
        "-log_dest", "lsst-build:/usr/local/home/buildbot/buildmaster/public_html/buildlogs", 
	"-log_url", "http://lsst-build:8010/buildlogs",
        "-builder_name", WithProperties("%s", "buildername"),
        "-build_number", WithProperties("%s", "buildnumber") , 
	"-slave_devel", TvsT_sandbox,
	"-parallel", 5,
	name , "trunk" ]))

    #--------------------------------------------------------------------
    # build trunk package against trunk --  but do NOT execute Unit Tests -- add step per package
    #--------------------------------------------------------------------
    # ditto for build trunk against trunk - NO TESTS
    f_TvsTNT.addStep( LogFileShellCommand(workdir="work", name=name, description=name + " trunkVtrunk",
        env=envT, timeout=3600, command=["time", slave_scripts_dir + "/trunkVsTrunk.sh",
        "-log_dest", "lsst-build:/usr/local/home/buildbot/buildmaster/public_html/buildlogs", 
	"-log_url", "http://lsst-build:8010/buildlogs",
        "-builder_name", WithProperties("%s", "buildername"), 
	"-build_number", WithProperties("%s", "buildnumber"), 
	"-slave_devel", TvsTNT_sandbox, 
	"-no_tests", 
	"-parallel", 2,
	name , "trunk" ]))

    #--------------------------------------------------------------------
    # monitor each package for trunk source change trigger  
    # --  ?Is this superfluous since the original change_source watches the ENTIRE DMS tree (all branches)?
    #--------------------------------------------------------------------
    package_branch = name.replace("_", "/")
    c['change_source'].append(SVNPoller("svn://svn.lsstcorp.org/DMS/" + 
        package_branch + "/trunk", pollinterval=300))

#--------------------------------------------------------------------
# build doxygen documentation for trunk Vs trunk but not for other build varients
#--------------------------------------------------------------------
envDoxy = {'xlinkdoxy':"set"}
envDoxy.update(envT)
f_TvsT.addStep( LogFileShellCommand(workdir="work", name="build doxyDoc", description="build doxygen docs",
    env=envDoxy, timeout=3600, command=[slave_scripts_dir + "/create_xlinkdocs.sh", "trunk",
    "buildbot@lsst-build.ncsa.illinois.edu:"+BUILDBOT_DOXYGEN, "http://dev.lsstcorp.org/doxygen"]))

# -- build trunk package against trunk dependencies
b_TvsT = { 
	'name': "Full_Trunk_vs_Trunk",
	'slavename': TRUNK_VS_TRUNK_SLAVE,
	'builddir': slave_builds_dir+"/TvT",
	'factory': f_TvsT
}
# -- build trunk package against trunk dependencies
b_TvsTNT = { 
	'name': "Full_Trunk_vs_Trunk_NO_TESTS",
	'slavename': TRUNK_VS_TRUNK_NO_TESTS_SLAVE,
	'builddir': slave_builds_dir+"/TvTNT",
	'factory': f_TvsTNT
}


#-----------------------------------------------------------------------------
# -- datarel's trunk-against-trunk  build
#----------------------------------------------------------------------------
datarel_sandbox = slave_home_dir+"/"+DATAREL_TRUNK_VS_TRUNK_SLAVE.split('.')[0]+"/sandbox"
f_datarel_TvsT = factory.BuildFactory()

# No 'step_update_pipe_lsst' on user-shared system unless using private LSST_HOME (as on Release/IncRelease)
f_datarel_TvsT.addStep( LogFileShellCommand(workdir="work", name="datarel", description="datarel trunkVtrunk",
    timeout=3600, env=envT,
    command=["time", slave_scripts_dir + "/prTrunkVsTrunk.sh", 
	"-log_dest", "lsst-build:/usr/local/home/buildbot/buildmaster/public_html/buildlogs",
        "-log_url", "http://lsst-build:8010/buildlogs", 
	"-builder_name", WithProperties("%s", "buildername"),
        "-build_number", WithProperties("%s", "buildnumber"),
	"-slave_devel", datarel_sandbox, 
	"-production", "datarel" , "trunk" ]))

b_datarel_TvsT = { 
	'name': "Datarel_Trunk_vs_Trunk",
	'slavename': DATAREL_TRUNK_VS_TRUNK_SLAVE, 
	'builddir': slave_builds_dir+"/datarel_trunkVsTrunk",
	'factory': f_datarel_TvsT 
}

#####
# build the doxygen docs
#####
doxygen_factory = factory.BuildFactory()

doxygen_env = {'LSST_HOME': LSST_HOME }

doxygen_factory.addStep(LogFileShellCommand(workdir="work", name="build doxyDoc", description="build doxygen docs", env=doxygen_env, timeout=3600, command=[slave_scripts_dir + "/create_xlinkdocs.sh", "current", "buildbot@lsst-build.ncsa.illinois.edu:/usr/local/home/buildbot/www", "http://dev.lsstcorp.org/doxygen"]))
build_doxygen = { 
	'name':'Doxygen',
	'slavename':TRUNK_VS_TRUNK_SLAVE, 
	'builddir' : slave_builds_dir+'/builds/Doxygen', 
	'factory' : doxygen_factory 
	}


#=============================================================================
#  Final Setup for Buildbot Master
#=============================================================================
# -- status
#from buildbot.status import html
#c['status'] = []
#c['status'].append(html.WebStatus(http_port=8010, allowForce=True))
#
#from buildbot.status import mail
#c['status'].append(mail.MailNotifier(fromaddr=buildbot_master,
#    extraRecipients=[buildbot_master],
#    mode="problem",    sendToInterestedUsers=True))

####### STATUS TARGETS

# 'status' is a list of Status Targets. The results of each build will be
# pushed to these targets. buildbot/status/*.py has a variety to choose from,
# including web pages, email senders, and IRC bots.

from buildbot.status.builder import Results

def messageFormatter(mode, name, build, results, master_status):
	result = Results[results]
	text = list()
	text.append("STATUS: %s" % result.title())
	return {
		'body' : "\n".join(text),
		'type' : 'plain'
	}


c['status'] = []

authz_cfg=authz.Authz(
    # change any of these to True to enable; see the manual for more
    # options
    gracefulShutdown = False,
    forceBuild = True, # use this to test your slave once it is set up
    forceAllBuilds = True,
    pingBuilder = False,
    stopBuild = True,
    stopAllBuilds = False,
    cancelPendingBuild = True,
)
c['status'].append(html.WebStatus(http_port=8010, authz=authz_cfg))

c['status'].append(mail.MailNotifier(fromaddr=buildbot_master,
    extraRecipients=[buildbot_master],
    mode="problem",    sendToInterestedUsers=True))

######

from buildbot.config import BuilderConfig

c['builders'] = []
c['builders'].append(build_release_pipeline)
c['builders'].append(build_doxygen)
c['builders'].append(b_TvsT)
c['builders'].append(b_TvsTNT)
c['builders'].append(b_datarel_TvsT)
c['builders'].append(on_demand_vs_trunk_builder)

####### PROJECT IDENTITY

# the 'title' string will appear at the top of this buildbot
# installation's html.WebStatus home page (linked to the
# 'titleURL') and is embedded in the title of the waterfall HTML page.

c['title'] = "LSST Build"
c['titleURL'] = "http://dev.lsstcorp.org/build2"

# the 'buildbotURL' string should point to the location where the buildbot's
# internal web server (usually the html.WebStatus page) is visible. This
# typically uses the port number set in the Waterfall 'status' entry, but
# with an externally-visible host name which the buildbot cannot figure out
# without some help.

c['buildbotURL'] = "http://lsst-build.ncsa.illinois.edu:8010/"

####### DB URL

# This specifies what database buildbot uses to store change and scheduler
# state.  You can leave this at its default for all but the largest
# installations.
c['db_url'] = "sqlite:///state.sqlite"

