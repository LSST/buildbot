# -*- python -*-
# ex: set syntax=python:

c = BuildmasterConfig = {}

# -------------------------------------------------------------------------
#       Set up Build Slaves
# -------------------------------------------------------------------------
from buildbot.buildslave import BuildSlave
# max_builds 1 because some tasks share an LSST stack, which doesn't handle simultaneous modifications well
# -- 64 bit buildbot Slaves --
c['slaves'] = [BuildSlave("trachea", "accio_build", notify_on_missing="rallsman@lsst.org", missing_timeout=300, max_builds=1),
               BuildSlave("traction", "accio_build", notify_on_missing="rallsman@lsst.org", missing_timeout=300, max_builds=1),
               #RAA#BuildSlave("trachodon", "accio_build", notify_on_missing="rallsman@lsst.org", missing_timeout=300, max_builds=1),
               BuildSlave("lsst6", "accio_build", notify_on_missing="rallsman@lsst.org", missing_timeout=300, max_builds=1),
# -- 32 bit buildbot Slaves --
               BuildSlave("tractor", "accio_build", notify_on_missing="rallsman@lsst.org", missing_timeout=300, max_builds=1),
# -- buildbot master --
#               BuildSlave("tracula", "accio_build", notify_on_missing="rallsman@lsst.org", missing_timeout=300, max_builds=1),
               ]
c['slavePortnum'] = 9989

from buildbot.changes.svnpoller import SVNPoller
c['change_source'] = []
#c['change_source'].append(SVNPoller("svn+ssh://svn.lsstcorp.org/DMS/", pollinterval=60))

from buildbot.scheduler import Scheduler
from buildbot.scheduler import Periodic
from buildbot.scheduler import Nightly
from buildbot.scheduler import Dependent
c['schedulers'] = []
#c['schedulers'].append(Scheduler(name="trigger", branch=None, treeStableTimer=2*60, builderNames=["test_repos_compile"]))
#c['schedulers'].append(Periodic(name="every two hours", periodicBuildTimer=7200, builderNames=["piecemeal", "monolithic"]))

# -------------------------------------------------------------------------
#        11:00 pm every night: install current release from scratch
# -------------------------------------------------------------------------
nightly_release = Nightly(name="Nightly release install", hour=22, minute=00, builderNames=["Release Pipeline"])
c['schedulers'].append(nightly_release)

# -------------------------------------------------------------------------
# 2:30 am every night: build trunk against (1)current & (2)minimum requirements
# -------------------------------------------------------------------------
# Not Useful# nightly_trunk = Nightly(name="Nightly trunk build", hour=2, minute=30, builderNames=["Full Trunk vs Current", "Full Trunk vs Minimal"])
# Not Useful# c['schedulers'].append(nightly_trunk)
# -------------------------------------------------------------------------

# -------------------------------------------------------------------------
#        11:00 pm every night: build trunk against trunk 
# -------------------------------------------------------------------------
#RAA#nightly_trunkVtrunk = Nightly(name="Nightly trunkVtrunk build", hour=22, minute=00, builderNames=["Full Trunk vs Trunk"])
nightly_trunkVtrunk = Nightly(name="Nightly trunkVtrunk build", hour=22, minute=15, builderNames=["Full Trunk vs Trunk"])
c['schedulers'].append(nightly_trunkVtrunk)

from buildbot.process import factory
from buildbot.steps.source import SVN
from buildbot.steps.shell import ShellCommand

log_args = "-log_dest tracula:/var/www/html/buildlogs -log_url http://dev.lsstcorp.org/buildlogs"

class LogFileShellCommand(ShellCommand):
    log_files = []
    log_files.append("config.log")
    log_files.append("build.log")

    def __init__(self, **kwargs):
        # And upcall to let the base class do its work
        ShellCommand.__init__(self, **kwargs)

    def createSummary(self, log):
        for line in log.getText().split("\n"):
            for log_file in self.log_files:
                # line format is "    log file build.log saved to http://dev.lsstcorp.org/...."
                if (line.startswith("log file ") and line.find(" saved to ") >= 0):
                    split = line.split(" saved to ", 1)
                    self.addURL(split[0].split("log file ")[1], split[1])

slave_home_dir = "/home/buildbot"
slave_scripts_dir = slave_home_dir + "/scripts"
slave_script_prefix = "time " + slave_scripts_dir

# -------------------------------------------------------------------------
#        Schedule a full build using LSSTPipe components
#                "Release Pipeline" 
# -------------------------------------------------------------------------
f_release_pipeline = factory.BuildFactory()
f_release_pipeline.addStep(ShellCommand(workdir="work",  name="erase", description="erase old working dir", command="rm -rf *"))
f_release_pipeline.addStep(ShellCommand(workdir="work", name="newinstall", description="install LSST tools", command=slave_script_prefix + "/run_newinstall.sh", timeout=3600))
# install LSSTPipe and check that pex_harness and mops are both installed
#f_release_pipeline.addStep(LogFileShellCommand(workdir="work", name="LSSTPipe", description="install LSSTPipe", command=slave_script_prefix + "/release_package.sh LSSTPipe pex_harness mops", timeout=14400))
# for now, don't check dependencies, since they change from time to time
f_release_pipeline.addStep(LogFileShellCommand(workdir="work", name="LSSTPipe", description="install LSSTPipe", command=slave_script_prefix + "/release_package.sh LSSTPipe", timeout=18000))
f_release_pipeline.addStep(LogFileShellCommand(workdir="work", name="Log Files", description="capture log files", command=slave_script_prefix + "/capture_logs.sh tracula:/var/www/html/buildlogs http://dev.lsstcorp.org/buildlogs build.log config.log", timeout=600))

b_release_pipeline_64_trachea = { 'name': "Release Pipeline", 'slavename': "trachea", 'builddir': "lsst_install_trachea", 'factory': f_release_pipeline }
#b_release_pipeline_64_traction = { 'name': "Release Pipeline", 'slavename': "traction", 'builddir': "lsst_install_traction", 'factory': f_release_pipeline }
#b_release_pipeline_32 = { 'name': "Release Pipeline 32", 'slavename': "tractor", 'builddir': "lsst_install_tractor", 'factory': f_release_pipeline }

# -------------------------------------------------------------------------
#        Schedule build but without starting from scratch 
#        -- that is, don't erase old working dir
#                "Release incremental"
# -------------------------------------------------------------------------
# Not Useful# f_release_no_erase = factory.BuildFactory()
# Not Useful# f_release_no_erase.addStep(LogFileShellCommand(workdir="work", name="LSSTPipe", description="install LSSTPipe", command=slave_script_prefix + "/release_package.sh LSSTPipe", timeout=14400))
# Not Useful# f_release_no_erase.addStep(LogFileShellCommand(workdir="work", name="Log Files", description="capture log files", command=slave_script_prefix + "/capture_logs.sh tracula:/var/www/html/buildlogs http://dev.lsstcorp.org/buildlogs build.log config.log", timeout=600))

# Not Useful# b_release_no_erase_64_trachea = { 'name': "Release incremental", 'slavename': "trachea", 'builddir': "lsst_install_trachea_2", 'factory': f_release_no_erase }
#b_release_no_erase_64_traction = { 'name': "Release incremental", 'slavename': "traction", 'builddir': "lsst_install_traction_2", 'factory': f_release_no_erase }
#b_release_no_erase_32 = { 'name': "Release 32 incremental", 'slavename': "tractor", 'builddir': "lsst_install_tractor_2", 'factory': f_release_no_erase }

# -------------------------------------------------------------------------
#        Collect module names for all DM modules
# -------------------------------------------------------------------------
import urllib2
#f = urllib2.urlopen("http://lsstdev.ncsa.uiuc.edu/dmspkgs/manifests/LSSTPipe-3.1.manifest")
f = urllib2.urlopen("http://dev.lsstcorp.org/dmspkgs/active.list")
manifest_lines = f.readlines()
pkgs = []
try:
    for line in manifest_lines:
        line = line.strip()
        if line.startswith('EUPS') or line.startswith('#') or line.find("external") >= 0:
            continue
        try:
            parts = line.split()
            if parts[0] == "scons":
                continue
            # 0 name, 1 flavor, 2 version, 3 tablefile, 4 install dir, 5 install id
            # pkgs.append([parts[0], parts[2], parts[3]])
            pkgs.append([parts[0]]) # active.list is not a manifest file, so don't parse it as one
        except IndexError:
            pass
finally:
    f.close()

# -------------------------------------------------------------------------
#    trigger a full trunk build on checkins 
#    "Full Trunk vs Current"  "Full Trunk vs Minimal"  "Full Trunk vs Trunk"
# -------------------------------------------------------------------------
trunk_uniq = []
# Not Useful# f_trunk_each = factory.BuildFactory()
# Not Useful# f_trunk_each_current = factory.BuildFactory()
step_update_pipe = LogFileShellCommand(workdir="work", name="update stack", description="update stack", timeout=12000, command=slave_script_prefix + "/release_package.sh -lsstdir /lsst/stacks/default -no_doxygen --tag=current LSSTPipe")
# Not Useful# f_trunk_each.addStep(step_update_pipe)
# Not Useful# f_trunk_each_current.addStep(step_update_pipe)

f_trunk_each_trunk = factory.BuildFactory()
step_update_pipe_lsst = LogFileShellCommand(workdir="work", name="update stack", description="update stack", timeout=12000, command=slave_script_prefix + "/release_package.sh -lsstdir /lsst/DC3/stacks/default -no_doxygen --tag=current LSSTPipe")
f_trunk_each_trunk.addStep(step_update_pipe_lsst)

all_packages = ""
for pkg_ver in pkgs:
    name = pkg_ver[0]
    if name in trunk_uniq: #skip duplicates
        continue
    trunk_uniq.append(name)
    all_packages = all_packages + " " + name

    # add a step for each package
    # Not Useful# trunk_cmd = slave_script_prefix + "/trunk_install.sh -force " + log_args + " " + name + " trunk"
    # Not Useful# trunk_step = LogFileShellCommand(workdir="work", name=name, description=name + " trunk", timeout=3600, command=trunk_cmd)
    # Not Useful# f_trunk_each.addStep(trunk_step)

    # ditto for build trunk against current
    # Not Useful# trunk_cmd_current = slave_script_prefix + "/trunk_install.sh -force -against_current " + log_args + " " + name + " trunk"
    # Not Useful# trunk_step_current = LogFileShellCommand(workdir="work", name=name, description=name + " trunk", timeout=3600, command=trunk_cmd_current)
    # Not Useful# f_trunk_each_current.addStep(trunk_step_current)

    # ditto for build trunk against trunk
    trunk_cmd_trunk = slave_script_prefix + "/trunkVsTrunk.sh " + log_args + " " + name + " trunk"
    trunk_step_trunk = LogFileShellCommand(workdir="work", name=name, description=name + " trunkVtrunk", timeout=3600, command=trunk_cmd_trunk)
    f_trunk_each_trunk.addStep(trunk_step_trunk)

    # monitor each package
    package_branch = name.replace("_", "/")
    c['change_source'].append(SVNPoller("svn+ssh://svn.lsstcorp.org/DMS/" + package_branch + "/trunk", pollinterval=300))

# -- build trunk against current
# Not Useful# b_trunk_each_current = { 'name': "Full Trunk vs Current", 'slavename': "traction", 'builddir': "trunk_current", 'factory': f_trunk_each_current }

# -- build trunk against minimal dependencies
# Not Useful# b_trunk_each_64 = { 'name': "Full Trunk vs Minimal", 'slavename': "trachea", 'builddir': "trunk_install_trachea", 'factory': f_trunk_each }
#b_trunk_each_32 = { 'name': "Full Trunk vs Minimal 32", 'slavename': "tractor", 'builddir': "trunk_install_tractor", 'factory': f_trunk_each }

# -- build trunk against trunk
#RAA#b_trunk_each_trunk = { 'name': "Full Trunk vs Trunk", 'slavename': "trachodon", 'builddir': "trunkVsTrunk_trachodon", 'factory': f_trunk_each_trunk }
b_trunk_each_trunk = { 'name': "Full Trunk vs Trunk", 'slavename': "lsst6", 'builddir': "trunkVsTrunk_lsst", 'factory': f_trunk_each_trunk }


# -------------------------------------------------------------------------
# -------------------------------------------------------------------------
#       trigger an incremental trunk build on checkins 
#       i.e. without starting from scratch 
#       -- that is, don't erase old working dir
#       "Trunk vs Current"  and  "Trunk vs Minimal" 
# -------------------------------------------------------------------------
f_triggered_current = factory.BuildFactory()
f_triggered_32 = factory.BuildFactory()
f_triggered_64 = factory.BuildFactory()
f_triggered_current.addStep(step_update_pipe)
f_triggered_32.addStep(step_update_pipe)
f_triggered_64.addStep(step_update_pipe)
triggered_cmd_current = slave_script_prefix + "/triggered_trunk.sh -against_current " + log_args + " -name \"Trunk vs Current\" " + all_packages
triggered_cmd_32 = slave_script_prefix + "/triggered_trunk.sh " + log_args + " -name \"Trunk 32\" " + all_packages
triggered_cmd_64 = slave_script_prefix + "/triggered_trunk.sh " + log_args + " -name \"Trunk vs Minimal\" " + all_packages
f_triggered_current.addStep(LogFileShellCommand(workdir="work", name="Incremental Trunk", description="Incremental Trunk Build", timeout=3600, command=triggered_cmd_current))
f_triggered_32.addStep(LogFileShellCommand(workdir="work", name="Incremental Trunk", description="Incremental Trunk Build", timeout=3600, command=triggered_cmd_32))
f_triggered_64.addStep(LogFileShellCommand(workdir="work", name="Incremental Trunk", description="Incremental Trunk Build", timeout=3600, command=triggered_cmd_64))

b_triggered_current_64 = { 'name': "Trunk vs Current", 'slavename': "traction", 'builddir': "triggered_current", 'factory': f_triggered_current }
b_triggered_minimal_64 = { 'name': "Trunk vs Minimal", 'slavename': "trachea", 'builddir': "triggered_64", 'factory': f_triggered_64 }
#b_triggered_32 = { 'name': "Trunk vs Minimal 32", 'slavename': "tractor", 'builddir': "triggered_32", 'factory': f_triggered_32 }

sched_trigger = Scheduler(name="trigger DMS", branch=None, treeStableTimer=11*60, builderNames=["Trunk vs Minimal", "Trunk vs Current"])
c['schedulers'].append(sched_trigger)

# -------------------------------------------------------------------------

c['status'] = []

from buildbot.status import html
c['status'].append(html.WebStatus(http_port=8010, allowForce=True))

from buildbot.status import mail
c['status'].append(mail.MailNotifier(fromaddr="rallsman@lsst.org", extraRecipients=["bbb@illinois.edu", "rallsman@lsst.org"], mode="problem", sendToInterestedUsers=True))

c['projectName'] = "LSST Build"
c['projectURL'] = "http://dev.lsstcorp.org/build/"
c['buildbotURL'] = "http://dev.lsstcorp.org/build/"

# -------------------------------------------------------------------------
# moved these all down here to control order of builders all in one place
# -------------------------------------------------------------------------
c['builders'] = []
c['builders'].append(b_triggered_current_64)
c['builders'].append(b_triggered_minimal_64)
#c['builders'].append(b_triggered_32)
# Not Useful# c['builders'].append(b_trunk_each_current)
# Not Useful# c['builders'].append(b_trunk_each_64)
#c['builders'].append(b_trunk_each_32)
c['builders'].append(b_release_pipeline_64_trachea)
#c['builders'].append(b_release_pipeline_64_traction)
#c['builders'].append(b_release_pipeline_32)
# Not Useful# c['builders'].append(b_release_no_erase_64_trachea)
#c['builders'].append(b_release_no_erase_64_traction)
#c['builders'].append(b_release_no_erase_32)
c['builders'].append(b_trunk_each_trunk)
